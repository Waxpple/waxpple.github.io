<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Waxapple Code Segment</title><link>https://waxpple.github.io/</link><description>Risc V daliy base.</description><generator>Hugo 0.81.0 https://gohugo.io/</generator><language>en</language><managingEditor>a0910618112@gmail.com (Waxapple)</managingEditor><webMaster>a0910618112@gmail.com (Waxapple)</webMaster><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><lastBuildDate>Wed, 14 Jul 2021 12:07:27 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://waxpple.github.io/rss.xml"/><item><title>[Day05] Simulations</title><link>https://waxpple.github.io/posts/day05/</link><guid isPermaLink="true">https://waxpple.github.io/posts/day05/</guid><pubDate>Wed, 14 Jul 2021 15:28:58 +0800</pubDate><author>a0910618112@gmail.com (Waxapple)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>&lt;h1 id="simulating">Simulating&lt;/h1>
&lt;p>The best way to simulate a module is through nMigen&amp;rsquo;s &lt;code>Simulator&lt;/code>.&lt;/p>
&lt;h2 id="define-you-ports">Define you ports&lt;/h2>
&lt;p>Define a &lt;code>ports&lt;/code> function in your module which returns an array of your module&amp;rsquo;s ports:&lt;/p>
&lt;pre>&lt;code>class YourModule(Elaboratable):
...
def ports(self):
return [self.youmodule.p1, self.yourmodule.p2, ...]
&lt;/code>&lt;/pre>&lt;h2 id="create-a-top-level-module">Create a top-level module&lt;/h2>
&lt;p>Create a top-level module for your simulation:&lt;/p>
&lt;pre>&lt;code>from nmigen import *
from nmigen.back.pysim import Simulator, Delay, Settle
from somewhere import YourModule
if __name__ == &amp;quot;__main__&amp;quot;:
m = Module()
m.submodules.yourmodule = yourmodule = YourModule()
sim = Simulator(m)
def process():
# To be defined
sim.add_process(process) # or sim.add_sync_process(process), see below
with sim.write_vcd(&amp;quot;test.vcd&amp;quot;, &amp;quot;test.gtkw&amp;quot;, traces=yourmodule.ports()):
sim.run()
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>There is currently a bug in nMigen where inputs to your module are not output to the trace file. To get around this, for each such input, place this in your &lt;code>main&lt;/code> before the &lt;code>Simulator&lt;/code> construction:&lt;/p>
&lt;pre>&lt;code>input1 = Signal()
m.d.comb += yourmodule.input1.eq(input1)
...
sim = Simulator(m)
&lt;/code>&lt;/pre>&lt;p>Inside your &lt;code>process&lt;/code>, refer to this input as &lt;code>input1&lt;/code>, not &lt;code>yourmodule.input1&lt;/code>. This will force nMigen to include &lt;code>input1&lt;/code> in the trace file.&lt;/p>
&lt;/blockquote></description></item><item><title>[Day04] Bit selection</title><link>https://waxpple.github.io/posts/day04/</link><guid isPermaLink="true">https://waxpple.github.io/posts/day04/</guid><pubDate>Tue, 13 Jul 2021 09:48:38 +0800</pubDate><author>a0910618112@gmail.com (Waxapple)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>&lt;h1 id="spliting-and-combining-signals">Spliting and combining signals&lt;/h1>
&lt;h2 id="slicing-signals">Slicing signals&lt;/h2>
&lt;p>We can get the least significant bit by &lt;code>x[0]&lt;/code> or the most significant bit by &lt;code>x[15]&lt;/code>.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; from nmigen import *
&amp;gt;&amp;gt;&amp;gt; x = Signal(16)
&amp;gt;&amp;gt;&amp;gt; x
(sig x)
&amp;gt;&amp;gt;&amp;gt; x.shape()
Shape(width=16, signed=False)
&amp;gt;&amp;gt;&amp;gt; x[15]
(slice (sig x) 15:16)
&amp;gt;&amp;gt;&amp;gt; x[15].shape()
Shape(width=1, signed=False)
&lt;/code>&lt;/pre>&lt;p>While &lt;code>x[7:0]&lt;/code> is the way to extract the eight least significant bits in verilog.But in nMigen we use &lt;code>x[0:8]&lt;/code> or &lt;code>x[:8]&lt;/code>. It will be &lt;code>Signal_name[start_bit:bits]&lt;/code>.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; x[7:0]
Traceback (most recent call last):
File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
File &amp;quot;/home/waxapple/.local/lib/python3.8/site-packages/nmigen/hdl/ast.py&amp;quot;, line 238, in __getitem__
return Slice(self, start, stop)
File &amp;quot;/home/waxapple/.local/lib/python3.8/site-packages/nmigen/hdl/ast.py&amp;quot;, line 659, in __init__
raise IndexError(&amp;quot;Slice start {} must be less than slice stop {}&amp;quot;.format(start, stop))
IndexError: Slice start 7 must be less than slice stop 0
&amp;gt;&amp;gt;&amp;gt; x[0:8]
(slice (sig x) 0:8)
&amp;gt;&amp;gt;&amp;gt; x[0:8].shape()
Shape(width=8, signed=False)
&lt;/code>&lt;/pre>&lt;p>Remember that since this is Python, negative indices are offsets from the end, so a way of getting the most significant bit is &lt;code>x[-1]&lt;/code>.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; x[-1]
(slice (sig x) 15:16)
&lt;/code>&lt;/pre>&lt;p>You can use strides: &lt;code>x[0:8:2]&lt;/code> which is &lt;code>signal_name[start_bit:bits:strides]&lt;/code>.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; x[0:8:2]
(cat (slice (sig x) 0:1) (slice (sig x) 2:3) (slice (sig x) 4:5) (slice (sig x) 6:7))
&lt;/code>&lt;/pre>&lt;p>Note that taking bits range selection will always result in unsigned signal.&lt;br>
You can even assign to a piece of a signal:&lt;/p>
&lt;pre>&lt;code>m.d.comb += x[:8].eq(y)
# same as the x[7:0] = {y[7:0]}; in verilog
&lt;/code>&lt;/pre>&lt;h1 id="tip-using-a-slice-when-comparing">Tip: Using a slice when comparing&lt;/h1>
&lt;p>In a situation like this:&lt;/p>
&lt;pre>&lt;code>a = Signal(unsigned(16))
b = Signal(unsigned(16))
c = Signal(unsigned(16))
m.d.comb += c.eq(a+b)
&lt;/code>&lt;/pre>&lt;p>We expect that if &lt;code>a+b&lt;/code> overflows, &lt;code>c&lt;/code> will just be the lower 16 bits of the result.&lt;/p>
&lt;pre>&lt;code>a = Signal(unsigned(16))
b = Signal(unsigned(16))
z = Signal()
m.d.comb += z.eq((a+b)== 0)
&lt;/code>&lt;/pre>&lt;p>However, z will be a 17-bit signal. So a 16-bit overflow is not a 17-bit overflow, and this will result in comparison failure. Such as &lt;code>a = 0xffff&lt;/code> and &lt;code>b = 0x0001&lt;/code>, the addition will be &lt;code>z = 0x10000&lt;/code>, which obviously not zero as we expected.&lt;br>
Therefore, be careful to slice the result&lt;/p>
&lt;pre>&lt;code>m.d.comb += z.eq((a+b)[:16] == 0)
&lt;/code>&lt;/pre>&lt;p>Alternatively, just use an intermediate signal (not recommanded):&lt;/p>
&lt;pre>&lt;code>tmp = Signal(unsigned(16))
m.d.comb += tmp.eq(a+b)
m.d.comb += z.eq(tmp == 0)
&lt;/code>&lt;/pre>&lt;p>This becomes especially insidious when combining unsigned and signed signals:&lt;/p>
&lt;pre>&lt;code>ptr = Signal(unsigned(16))
addr = Signal(unsigned(16))
offset = Signal(signed(5))
m.d.comb += ptr.eq(addr + offset)
&lt;/code>&lt;/pre>&lt;p>we expect &lt;code>ptr&lt;/code> to be a 16-bit value, since that is what we set it to be. However, what happens here?
Suppose &lt;code>addr&lt;/code> is 0 and &lt;code>offset&lt;/code> is -1. Will this comparison work? No, sorry my dear. It wouldn&amp;rsquo;t work.
Consider that &lt;code>adder&lt;/code> range from &lt;code>0x7FFF to 0xFFFF&lt;/code> and &lt;code>offset&lt;/code> range from &lt;code>0x7 to 0xF&lt;/code>, which is max((+32767 ~ -32768) + (+7 ~ -8) )= &lt;code>0x8006&lt;/code>&lt;/p>
&lt;pre>&lt;code>y = Signal()
m.d.comb += y.eq((addr + offset) == 0xFFFF )
&lt;/code>&lt;/pre>&lt;p>So the result of &lt;code>addr+offset&lt;/code> in this is -1, which 2&amp;rsquo;s complement 18-bit is &lt;code>0x3FFFF&lt;/code>. If we slice it, it will be &lt;code>0xFFFF&lt;/code>.&lt;/p>
&lt;h1 id="concatenating-signals">Concatenating signals&lt;/h1>
&lt;p>You can create a new signal out of other signals using &lt;code>Cat&lt;/code>:&lt;/p>
&lt;pre>&lt;code>m.d.comb += x.eq(Cat(a, b, ...))
&lt;/code>&lt;/pre>&lt;p>This concatenates the given signals &lt;em>first element last&lt;/em> This is important that a in the example above ends up as the least significant bits of x. That is, the concatenation of &lt;code>a&lt;/code> and &lt;code>b&lt;/code> is not &lt;code>ab&lt;/code> but &lt;code>ba&lt;/code>.&lt;br>
It is now easy to swap the bytes of a 16-bit signal:&lt;/p>
&lt;pre>&lt;code>m.d.sync += x.eq(Cat(x[8:], x[:8]))
&lt;/code>&lt;/pre>&lt;p>You can also assign to a &lt;code>Cat&lt;/code>, so swapping the bytes can be accomplished in this way also:&lt;/p>
&lt;pre>&lt;code>m.d.sync += Cat(x[8:], x[:8]).eq(x)
&lt;/code>&lt;/pre>&lt;h1 id="replicating-signals">Replicating signals&lt;/h1>
&lt;p>You can replicate a signal by concatenating it to itself via &lt;code>Cat(x,x)&lt;/code>. But you can also replicate the signal via &lt;code>Repl(x,2)&lt;/code>
&lt;code>Repl&lt;/code> with &lt;code>Cat&lt;/code> can be used together to, for example, signed-extend a value:&lt;/p>
&lt;pre>&lt;code>uint16 = Signal(unsigned(16))
int32 = Signal(signed(32))
m.d.comb += int32.eq(Cat(uint16, Repl(uint16[15],16)))
&lt;/code>&lt;/pre>&lt;p>Of course, the same can be done by simply using the right signal types:&lt;/p>
&lt;pre>&lt;code>uint16 = Signal(unsigned(16))
int32 = Signal(signed(32))
m.d.comb += int32.eq(uint16)
&lt;/code>&lt;/pre>&lt;p>The generated cide will do the right thing.&lt;/p>
&lt;h1 id="arrays">Arrays&lt;/h1>
&lt;p>You can create an array of signals like this:&lt;/p>
&lt;pre>&lt;code># All of these create an array of 3 16-bit elements:
# Creates an array from a, b, c:
a = Signal(unsigned(16))
b = Signal(unsigned(16))
c = Signal(unsigned(16))
abc = Array([a, b, c])
# Creates an array of 16-bit signals:
x = Array([Signal(unsigned(16)), Signal(unsigned(16)), Signal(unsigned(16)) ])
# Also creates an array of 16-bit signals, taking
y = Array([Signal(unsigned(16)) for_ in range(3)])
&lt;/code>&lt;/pre>&lt;p>You can even create multidimensional arrays:&lt;/p>
&lt;pre>&lt;code># Creates a 3 by 5 array of 16-bit signals:
yy = Array([Array[Signal(unsigned(16)) for _ in range(5)] for _ in range(3) ])
&lt;/code>&lt;/pre>&lt;p>You can index into the array with a constant:&lt;/p>
&lt;pre>&lt;code>z = y[2]
&lt;/code>&lt;/pre>&lt;p>This will result in an &amp;ldquo;elaborate time&amp;rdquo; error if the index is out of bounds.
However, you can also index with another signal:&lt;/p>
&lt;pre>&lt;code>i = Signal(unsigned(16))
z = y[i]
&lt;/code>&lt;/pre>&lt;p>Of course, during elaboration this will not result in any error. The actual result depends on runtime. It is best to ensure as much as possible that your access is not invalid. One way is to declare the index to only have a valid range.&lt;/p>
&lt;pre>&lt;code>y = Array([Signal(unsigned(16)) for _ in range(5)])
i = Signal.range(5)
z = y[i]
&lt;/code>&lt;/pre>&lt;p>Of course, there is nothing to prevent &lt;code>i&lt;/code> from being 5, 6, or 7, since it is a 3-bit signal.
Another way is to simply deal with invalid values:&lt;/p>
&lt;pre>&lt;code>y = Array([Signal(unsigned(16)) for _ in range(5)])
i = Signal.range(5)
z = y[i % 4]
&lt;/code>&lt;/pre>&lt;p>Note here, it will still result in unexpected result.
In the end, you will have to &lt;code>formally verify&lt;/code> that i will only contain valid values.&lt;/p>
&lt;h1 id="records">Records&lt;/h1>
&lt;p>A &lt;code>Record&lt;/code> is a bundle of signals. To define a &lt;code>Record&lt;/code>, we first must define a &lt;code>Layout&lt;/code>.&lt;/p>
&lt;h2 id="layouts">Layouts&lt;/h2>
&lt;pre>&lt;code>from nmigen.hdl.rec import *
class MyLayout(Layout):
def __init__(self):
super().__init__([
(&amp;lt;signal_name&amp;gt;, &amp;lt;shape|layout&amp;gt; [, &amp;lt;direction&amp;gt;]),
(&amp;lt;signal_name&amp;gt;, &amp;lt;shape|layout&amp;gt; [, &amp;lt;direction&amp;gt;]),
])
&lt;/code>&lt;/pre>&lt;p>Here is an example of a bus with 8-bit data, 16-bit address line, and some control signals:&lt;/p>
&lt;pre>&lt;code>class BusLayout(Layout):
def __init__(self):
super().__init__([
(&amp;quot;data&amp;quot;, unsigned(8)),
(&amp;quot;addr&amp;quot;, unsigned(16)),
(&amp;quot;wr&amp;quot;,1),
(&amp;quot;en&amp;quot;,1),
])
&lt;/code>&lt;/pre>&lt;p>If your bus is very complex and easy to reuse another bus, you can define a bus by another bus.&lt;/p>
&lt;pre>&lt;code>class DataBusLayout(Layout):
def __init__(self):
super().__init__([
(&amp;quot;data&amp;quot;,unsigned(8))
])
class AddrBusLayout(Layout):
def __init__(self):
super().__init__([
(&amp;quot;addr&amp;quot;,unsigned(16))
])
class AllBusLayout(Layout):
def __init__(self):
super().__init__([
(&amp;quot;addr_bus&amp;quot;,AddrBusLayout()),
(&amp;quot;data_bus&amp;quot;,DataBusLayout()),
])
&lt;/code>&lt;/pre>&lt;h2 id="laying-out-a-record-with-a-layout">Laying out a record with a layout&lt;/h2>
&lt;p>Once a &lt;code>Layout&lt;/code> is defined, you can define a &lt;code>Record&lt;/code> using that &lt;code>Layout&lt;/code>, and use it as a signal:&lt;/p>
&lt;pre>&lt;code>class Bus(Record):
def __init__(self):
super().__init__(BusLayout())
...
# Later in a module:
self.bus = Bus()
m.d.comb += self.bus.data.eq(0xFF)
m.d.sync += self.bus.wr.eq(0)
# Can assign a bus by a bus
self.bus2 = Bus()
m.d.comb += self.bus2.eq(self.bus)
&lt;/code>&lt;/pre>&lt;h1 id="directions-and-connecting-records">Directions and connecting records&lt;/h1>
&lt;p>It is often advantageous to define signals so that the zero value means either invalid or inactive. That way, you can have many of those signals and logical-or them together. For example, you might have three modules, each of which output a one-bit write signal, but only one module will write at a time. Then if your write signal is active high( zeros means no write), you can simply logical-or the write signal from each module together to get a master write signal.
&lt;img src="https://github.com/Waxpple/waxpple.github.io/blob/main/images/Bus_01.png" alt="2">&lt;/p>
&lt;pre>&lt;code>self.master_record = Bus()
m.d.comb += self.master_record.connect(bus1, bus2, bus3, ...)
&lt;/code>&lt;/pre>&lt;p>The &lt;code>connect&lt;/code> method on a record returns an array of statement which logical-ors each signal together.
The exactly same thing could be accomplished &amp;ldquo;manually&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>self.master_record = Bus()
m.d.comb += self.master_record.eq(bus1 | bus2 | bus3 |...)
&lt;/code>&lt;/pre>&lt;p>The disadvantage is that &lt;code>connect&lt;/code> can connect &lt;em>parts&lt;/em> of records, if the field names matched. In this sense, the &amp;ldquo;subordinate&amp;rdquo; records must have every signal that the &amp;ldquo;master&amp;rdquo; record has. That is, the &amp;ldquo;subordinate&amp;rdquo; records can have extra signals, but the &amp;ldquo;master&amp;rdquo; record must not.&lt;br>
Fan-out is where each subordinate record gets a copy of the master record. If the direction of each signal in the layout of record is &lt;code>DIR_FANOUT&lt;/code>, then you can connect several records to a &amp;ldquo;master&amp;rdquo; record like this:&lt;/p>
&lt;pre>&lt;code>self.master_record = Bus()
m.d.comb += self.master_record.connect(bus1, bus2, bus3, ...)
&lt;/code>&lt;/pre>&lt;p>The syntax is exactly the same, but the direction is different, from master record to each subordinate record. Again, you could do this &amp;ldquo;manually&amp;rdquo;:&lt;/p>
&lt;pre>&lt;code>self.master_record = Bus()
m.d.comb += [
bus1.eq(self.master_record),
bus2.eq(self.master_record),
bus3.eq(self.master_record),
...
]
&lt;/code>&lt;/pre>&lt;p>But this is longer, and also doesn&amp;rsquo;t handle when the master record has extra signals that not in the subordinate records.&lt;/p></description></item><item><title>[Day03] Branching</title><link>https://waxpple.github.io/posts/day03/</link><guid isPermaLink="true">https://waxpple.github.io/posts/day03/</guid><pubDate>Mon, 12 Jul 2021 14:38:07 +0800</pubDate><author>a0910618112@gmail.com (Waxapple)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>&lt;h1 id="if-elif-else">If-Elif-Else&lt;/h1>
&lt;p>you cannot use the standard python &lt;code>if-elif-else&lt;/code> statements to create statements. Instead, using nMigen branching.&lt;/p>
&lt;pre>&lt;code>with m.If(condition1):
m.d.comb += statements1
with m.Elif(condition2):
m.d.comb += statements2
with m.Else():
m.d.comb += statements3
&lt;/code>&lt;/pre>&lt;p>If you use regular Python &lt;code>if-elif-else&lt;/code>, then those will be evaluated during &lt;em>generation&lt;/em> of the logic, not the logic itself. This can be useful if you want a flag to cause different logic implement to be generated, and this is a good use of platform string pass to elaborate().&lt;/p>
&lt;pre>&lt;code>if (platform== &amp;quot;KC705&amp;quot;)
m.d.comb += statement1
else:
m.d.comb += statement2
&lt;/code>&lt;/pre>&lt;p>If &lt;code>platform&lt;/code> is &lt;code>&amp;quot;KC705&amp;quot;&lt;/code> then statement1 will be implement in generated hardware, otherwise only statement2 will be implement in the design.&lt;/p>
&lt;h1 id="conditions">Conditions&lt;/h1>
&lt;p>The conditions in &lt;code>If-Elif-Else&lt;/code> are cimparisons, for example &lt;code>a == 1&lt;/code> or &lt;code>(a &amp;gt;= b) &amp;amp; (a &amp;lt;= c)&lt;/code>. Note that each comparison will be one-bit comparison.&lt;br>
If you have a signal with more than one bit and use it as the condition, use &lt;code>with m.If(a):&lt;/code>, then the condition will be true if any bit in a is 1.&lt;/p>
&lt;h1 id="switch-case-default">Switch-Case-Default&lt;/h1>
&lt;p>You can use &lt;code>Switch-Case-Default&lt;/code> just as in standard HDLs using the following &lt;code>with&lt;/code> constructs:&lt;/p>
&lt;pre>&lt;code>with m.Switch(expression):
with m.Case(value1):
statements1
with m.Case(value2):
statements2
with m.Default():
statements3
&lt;/code>&lt;/pre>&lt;p>Although it is suggested that using &lt;code>full-case&lt;/code> switch that we used to do in verilog. You can use multiple values in one case statement.&lt;/p>
&lt;pre>&lt;code>with m.Switch(expression):
with m.Case(value1,value2):
statements1
with m.Default():
statements3
&lt;/code>&lt;/pre>&lt;p>You can leave out the &lt;code>Defalt()&lt;/code>, but not suggest you to do that.&lt;/p>
&lt;pre>&lt;code>m.d.comb += x.eq(1)
with m.Switch (y):
with m.Case(0,1,2):
m.d.comb += x.eq(2)
&lt;/code>&lt;/pre>&lt;p>In this example, if &lt;code>y is in [0, 1, 2]&lt;/code> then &lt;code>x&lt;/code> is assigned 2. Otherwise &lt;code>x&lt;/code> retains its value of 1.&lt;/p>
&lt;ul>
&lt;li>Recall the section on overriding statements. One signal can only assigned in only one clock domain.&lt;/li>
&lt;/ul>
&lt;h1 id="specify-a-bit-patterns">Specify a bit patterns&lt;/h1>
&lt;p>The way to specify a matching pattern in a &lt;code>Case&lt;/code> is with a Python string of binary digits. For example, &lt;code>&amp;quot;0011101011&amp;quot;&lt;/code>. A don&amp;rsquo;t-care bit is specified using a dash &lt;code>-&lt;/code>, so for example &lt;code>&amp;quot;00111-----&amp;quot;&lt;/code>. The number of bits in the string must exactly the same as the number of bits in the expression it is being compared to.&lt;/p>
&lt;pre>&lt;code>with m.If(a.matches(&amp;quot;11---&amp;quot;,3,b)):
statement1
&lt;/code>&lt;/pre>&lt;p>Is equivelent to&lt;/p>
&lt;pre>&lt;code>with m.Switch(a):
with m.Case(&amp;quot;11---&amp;quot;,3,b):
statement1
&lt;/code>&lt;/pre></description></item><item><title>[Day02] Basic terminology</title><link>https://waxpple.github.io/posts/day02/</link><guid isPermaLink="true">https://waxpple.github.io/posts/day02/</guid><pubDate>Mon, 12 Jul 2021 10:01:41 +0800</pubDate><author>a0910618112@gmail.com (Waxapple)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>&lt;h1 id="domains">Domains&lt;/h1>
&lt;p>A &lt;em>domain&lt;/em> in its basic definition, is a grouping of logic cells. If consider a module as a blackbox. With its inputs and outputs, any given output is generated within one and only one domain.&lt;br>
&lt;code>Modules&lt;/code> come with two domain built in: a combinational domain and a sequential(synchronous) domain.&lt;/p>
&lt;h1 id="combinational">Combinational&lt;/h1>
&lt;p>Logic that contains no clocked elements is called combinational logic. This is one of the domain that a &lt;code>Module&lt;/code> contains. It is always named &lt;code>comb&lt;/code>, and it can be accessed via m.d.comb.&lt;br>
m means &lt;code>Module&lt;/code> and d means &lt;code>domain&lt;/code>.&lt;/p>
&lt;h1 id="synchronous">Synchronous&lt;/h1>
&lt;p>Logic that contains clocked elements is called synchronous (a.k.a sequential circuit) because all the FFs are triggered by particular clock domain. Each clock domain also has a reset signal which can reset all FFs to a given state. Finally, the domain specifies the edge of its clock on which all the FFs change: &lt;code>posedge&lt;/code> or &lt;code>negedge&lt;/code>.&lt;br>
Unless otherwise specified, there is one synchronous domain in a &lt;code>Module&lt;/code> called sync. It can be accessed via &lt;code>m.d.sync&lt;/code>.&lt;/p>
&lt;h1 id="creating-more-domains">Creating more domains&lt;/h1>
&lt;p>There is no reason to create combinational domains. As mentioned above, modules already contain one combinational domain, comb.&lt;br>
You can create a synchronous clock domain using &lt;code>ClockDomain(&amp;quot;&amp;lt;domain-name&amp;gt;&amp;quot;, clk_edge=&amp;quot;pos|neg&amp;quot;)&lt;/code>. This gives you both the clock and the reset signal for the domain. By default, the domain name is &lt;code>sync&lt;/code> and the clock edge is &lt;code>pos&lt;/code>.&lt;/p>
&lt;pre>&lt;code>m = Module()
mydomain = ClockDomain(&amp;quot;clk&amp;quot;)
m.domains += mydomain
m.d.mydomain += ... # logic to add in the &amp;quot;mydomain&amp;quot; clock domain.
&lt;/code>&lt;/pre>&lt;p>You can access a domain within a module by its name. So a domain created via ClockDomain(&amp;ldquo;my clock&amp;rdquo;) is accessed via &lt;code>m.d.myclock&lt;/code> or &lt;code>m.d[&amp;quot;myclk&amp;quot;]&lt;/code>. \&lt;/p>
&lt;ul>
&lt;li>&lt;code>ClockSignal(domain=&amp;quot;&amp;lt;domain&amp;gt;&amp;quot;)&lt;/code> gives you the clock signal for the given domain.&lt;/li>
&lt;li>&lt;code>ResetSignal(domain=&amp;quot;&amp;lt;domain&amp;gt;&amp;quot;)&lt;/code> gives you the reset signal for the given domain.&lt;/li>
&lt;/ul>
&lt;h1 id="tips-clock-domains-with-the-same-clock-but-different-edges">Tips: Clock domains with the same clock but different edges.&lt;/h1>
&lt;p>This can be done simply by creating one &lt;code>clockdomain&lt;/code>&lt;/p>
&lt;pre>&lt;code>pos = ClockDomain(&amp;quot;pos&amp;quot;)
neg = ClockDomain(&amp;quot;neg&amp;quot;, clk_edge=&amp;quot;neg&amp;quot;)
&lt;/code>&lt;/pre>&lt;p>Next, assign them with same clock driven&lt;/p>
&lt;pre>&lt;code>neg.clk = pos.clk
neg.rst = pos.rst
&lt;/code>&lt;/pre>&lt;p>And then you can add these to the module. We can add more than domain to a module with the same statement.&lt;/p>
&lt;pre>&lt;code>m.domains += [pos, neg]
&lt;/code>&lt;/pre>&lt;h1 id="access-to-domains">Access to domains&lt;/h1>
&lt;p>A module can access its domains via its &lt;code>d&lt;/code> attribute. By default, if a synchronous domain is added to a module&amp;rsquo;s &lt;code>domain&lt;/code>, then all modules everywhere will also have access to that domain via their d attribute, even if that module is not a submodule of the module where the domain was added.&lt;/p>
&lt;pre>&lt;code>m = Module()
m2 = Module()
m.domains += ClockDomain(&amp;quot;thing&amp;quot;)
m.d.thing += # logic
# This is implicity
m2.d.thing += #logic
&lt;/code>&lt;/pre>&lt;p>If you want to explicitly inhibit this global propagation by setting the &lt;code>local&lt;/code> named parameter of the &lt;code>ClockDomain&lt;/code> to &lt;code>True&lt;/code>.&lt;/p>
&lt;pre>&lt;code>m = Module()
m2 = Module()
m.domains += ClockDomain(&amp;quot;thing&amp;quot;, local=True)
m.d.thing += # logic
# Error will occur here.
m2.d.thing += # logic
&lt;/code>&lt;/pre>&lt;h1 id="ports">Ports&lt;/h1>
&lt;p>The equivalent of ports in a module is public attributes. In the following example, &lt;code>a&lt;/code> and &lt;code>data&lt;/code> are publicly available to other modules, while &lt;code>b&lt;/code> is not, just as &lt;code>a&lt;/code> and &lt;code>data&lt;/code> are publicly available to other python classes, and &lt;code>b&lt;/code> is not.&lt;/p>
&lt;pre>&lt;code>class ThingBlock(Elaboratable):
def __init__(self):
# Public accessible
self.a = Signal()
self.data = Signal(8)
def elaborate(self, platform: str):
m = Module()
# Internal use reg/wire.
b = Signal()
return m
&lt;/code>&lt;/pre>&lt;h1 id="resetdefault-values-for-signals">Reset/default values for signals&lt;/h1>
&lt;p>If a &lt;code>Signal&lt;/code> is set in the &lt;em>combinational&lt;/em> or &lt;em>synchronous&lt;/em> domain, then you can specify the default value of the signal if it is not set. By default value of the signal if it is not set. By default, it is zero, but for a non-zero value, you can specify the default value for a signal when constructing the signal by setting the &lt;code>reset&lt;/code> named parameter in the constructor. For example, this create a 16-bit signed signal, self.x, which initial value set to 0xFFFF.&lt;/p>
&lt;pre>&lt;code>self.x = Signal(signed(16), reset=0xFFFF) # initial value &amp;quot;0xFFFF&amp;quot;
&lt;/code>&lt;/pre>&lt;h1 id="explicitly-not-resetting">Explicitly not resetting&lt;/h1>
&lt;p>For synchronous signals(that is, a signal set in a synchronous domain), you can specify that it is not reset on the reset signal, instead only getting an initial balue on power-up. This is done by setting the &lt;code>reset_less&lt;/code> named parameter in the constructor to &lt;code>True&lt;/code>&lt;/p>
&lt;pre>&lt;code>self.x = Signal(signed(16),reset= 0xFFFF, reset_less = True)
&lt;/code>&lt;/pre>&lt;p>This is especially useful during simulation or formal verification where you want to activate the reset, but keep some signals &amp;ldquo;outside&amp;rdquo; the reset. For example, a cycle counter that maintains its count across resets.&lt;/p>
&lt;h1 id="basic-operations">Basic operations&lt;/h1>
&lt;h2 id="statements">Statements&lt;/h2>
&lt;p>nMigen doesn&amp;rsquo;t convert Python to hardware. In essence, what you are writing using nMigen is a &lt;em>generator&lt;/em> of logic, not the logic itself. So if you want to assign one &lt;code>Value&lt;/code> to take the value of another, you don&amp;rsquo;t write &lt;code>a = b&lt;/code>, but instead you call the method of &lt;code>a&lt;/code> that generates the equality: &lt;code>a.eq(b)&lt;/code>. This is known as a &lt;em>statement&lt;/em>.&lt;br>
However, many math operators are overridable in Python, since these translate to calls to Python functions. So for example, you can write &lt;code>a.eq(b+1)&lt;/code> instead of something like a.eq(b.plus(1)) because Python addition can be overrideen to a function callm and nMigen&amp;rsquo;s Signal class does that for all such operators (&lt;code>=&lt;/code> is still not overrided).&lt;/p>
&lt;h2 id="list-of-directly-translatable-python-operators">List of directly translatable Python operators&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Operator&lt;/th>
&lt;th style="text-align:center">Operation&lt;/th>
&lt;th>Notes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>~&lt;/code>&lt;/td>
&lt;td style="text-align:center">inversion&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>-&lt;/code>&lt;/td>
&lt;td style="text-align:center">arithmetic negation&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>+&lt;/code>&lt;/td>
&lt;td style="text-align:center">addition&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>*&lt;/code>&lt;/td>
&lt;td style="text-align:center">multiplication&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>%&lt;/code>&lt;/td>
&lt;td style="text-align:center">modulus&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>//&lt;/code>&lt;/td>
&lt;td style="text-align:center">division&lt;/td>
&lt;td>integer division, rounding down&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;&amp;lt;&lt;/code>&lt;/td>
&lt;td style="text-align:center">shift left&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;&amp;gt;&lt;/code>&lt;/td>
&lt;td style="text-align:center">shift right&lt;/td>
&lt;td>Effectively arithmetic, see below.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;amp;&lt;/code>&lt;/td>
&lt;td style="text-align:center">bitwise and&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>`&lt;/td>
&lt;td style="text-align:center">`&lt;/td>
&lt;td>bitwise or&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>^&lt;/code>&lt;/td>
&lt;td style="text-align:center">bitwise xor&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>==&lt;/code>&lt;/td>
&lt;td style="text-align:center">equality&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!=&lt;/code>&lt;/td>
&lt;td style="text-align:center">inequality&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;&lt;/code>&lt;/td>
&lt;td style="text-align:center">greater than&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;=&lt;/code>&lt;/td>
&lt;td style="text-align:center">greater than or equal to&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;&lt;/code>&lt;/td>
&lt;td style="text-align:center">less than&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;=&lt;/code>&lt;/td>
&lt;td style="text-align:center">less than equal to&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>Note that there are no translatable Python logical operators (&lt;code>and&lt;/code>,&lt;code>or&lt;/code>). The logical reduction functions &lt;code>any&lt;/code> and &lt;code>all&lt;/code> are not avaliable in nMigen expressions.&lt;br>
Attemped to convert nMigen value to boolean error will occur.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Shift right is effectively arithmetic, where the sign bit is present for signed values or zero for unsigned Values.&lt;/p>
&lt;/blockquote>
&lt;h1 id="effects-of-operations-on-result-width">Effects of operations on result width&lt;/h1>
&lt;p>Two unsigned/signed 4-bit signals addition will result in unsigned/signed 5-bit result.&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; s1 = Signal(signed(4))
&amp;gt;&amp;gt;&amp;gt; s2 = Signal(signed(4))
&amp;gt;&amp;gt;&amp;gt; v2 = s1 + s2
&amp;gt;&amp;gt;&amp;gt; v2.shape()
Shape(width=5, signed=True)
&lt;/code>&lt;/pre>&lt;h1 id="multiplexing-signals">Multiplexing signals&lt;/h1>
&lt;p>&lt;code>Mux()&lt;/code> returns one signal if the condition is true, the other signal otherwise:&lt;/p>
&lt;pre>&lt;code>y.eq(Mux(cond,x1,x2))
&lt;/code>&lt;/pre>&lt;p>In this case, if &lt;code>cond&lt;/code> is true then &lt;code>y&lt;/code> is set to x1, otherwise x2. It is the same as &lt;code>y = cond?x1:x2;&lt;/code>.&lt;br>
&lt;code>Mux&lt;/code> cannot be used on the left-hand side of any assignment.&lt;/p>
&lt;h1 id="placing-statements-in-domains">Placing statements in domains&lt;/h1>
&lt;p>Statements are written in the combinational domain of a module as we used to in verilog. Ofcourse, can be used in sequential circuits.&lt;/p>
&lt;pre>&lt;code># Combinational circuit
m.d.comb += x.eq(y+1)
# Sequential circuit
m.d.sync += x.eq(y+1)
&lt;/code>&lt;/pre>&lt;p>For example, y is &lt;code>IDLE&lt;/code> and x is next_state.&lt;/p>
&lt;h1 id="adding-multiple-statements">Adding multiple statements&lt;/h1>
&lt;p>The &lt;code>+=&lt;/code> operator for a domain can take one statement, or a list of statements, which is pretty ease to use.&lt;/p>
&lt;pre>&lt;code>m.d.comb += [
x.eq(y+1),
z.eq(w+2)
]
&lt;/code>&lt;/pre>&lt;h1 id="conflict-statements-will-be-override">Conflict statements will be override&lt;/h1>
&lt;p>If a statement sets the same signal that previous statement set, the the second set takes precedence.&lt;/p>
&lt;pre>&lt;code>m.d.comb += x.eq(y+1)
m.d.comb += x.eq(y+2)
&lt;/code>&lt;/pre>&lt;p>In this case, x will get y+2 not y+1.
Remember that one signal can only be assigned to one domains, otherwise, it will result in a driver-driver conflict.&lt;/p>
&lt;pre>&lt;code># Wrong code
m.d.comb += x.eq(y+1)
m.d.sync += x.eq(y+1)
&lt;/code>&lt;/pre></description></item><item><title>[Day01] Basic nMigen</title><link>https://waxpple.github.io/posts/day01/</link><guid isPermaLink="true">https://waxpple.github.io/posts/day01/</guid><pubDate>Sat, 10 Jul 2021 10:50:02 +0800</pubDate><author>a0910618112@gmail.com (Waxapple)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>&lt;h1 id="basic-structure-of-modules">Basic structure of modules&lt;/h1>
&lt;p>The tutorial is followed by &lt;a href="https://github.com/RobertBaruch/nmigen-tutorial/">https://github.com/RobertBaruch/nmigen-tutorial/&lt;/a>
Thumbs up for his contributions.&lt;/p>
&lt;pre>&lt;code>from nmigen import *
from nmigen.build import Platform
class ThingBlock(Elaboratable):
def __init__(self):
pass
def elaborate(self, platform: Platform) -&amp;gt; Module:
m = Module()
return m
&lt;/code>&lt;/pre>&lt;h1 id="elaborating-a-module">Elaborating a module&lt;/h1>
&lt;pre>&lt;code>from nmigen.cli import main
if __name__== &amp;quot;__main__&amp;quot;:
sync = ClockDomain()
block = ThingBlock()
m = Module()
m.domains += sync
m.submodules += block
main(m, ports=[sync.clk,sync.rst])
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>main(module, ports=[&lt;ports>], platform=&amp;quot;&lt;platform>&amp;quot;) translate the given module into verilog. This is call &lt;em>elaboration&lt;/em>. All elaborate() medthod will have its platform argument set to the given platform like particular chips or evaluation boards.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>python3 thing.py generate -t [v|il] &amp;gt; thing.[v|il]
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>If you encounter any error message, Back to day00 and install the pre-requisties.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Choose RTLIL if using yosys.&lt;/li>
&lt;/ul></description></item><item><title>[Day00] nMigen 戰鬥</title><link>https://waxpple.github.io/posts/day00/</link><guid isPermaLink="true">https://waxpple.github.io/posts/day00/</guid><pubDate>Fri, 09 Jul 2021 14:33:00 +0800</pubDate><author>a0910618112@gmail.com (Waxapple)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright><description>&lt;h1 id="第一天接觸nmigen-先來安裝nmigen">第一天接觸nMigen, 先來安裝　nMigen!&lt;/h1>
&lt;p>&lt;img src="https://m-labs.hk/images/migen@2x.png?h=43d4e86170d805ce58f90901ae31a64141ea32606f7cefcb4b2b165e362c2b9a" alt="1">&lt;/p>
&lt;h1 id="安裝prerequisites">安裝Prerequisites&lt;/h1>
&lt;pre>&lt;code>sudo apt-get install build-essential clang bison flex libreadline-dev \
gawk tcl-dev libffi-dev git mercurial graphviz \
xdot pkg-config python python3 libftdi-dev gperf \
libboost-program-options-dev autoconf libgmp-dev \
cmake
&lt;/code>&lt;/pre>&lt;h1 id="安裝有的沒的必備程式">安裝有的沒的必備程式&lt;/h1>
&lt;p>參考 &lt;a href="https://symbiyosys.readthedocs.io/en/latest/install.html">https://symbiyosys.readthedocs.io/en/latest/install.html&lt;/a>&lt;/p>
&lt;h1 id="安裝nmigen">安裝nMigen&lt;/h1>
&lt;pre>&lt;code>pip install git+https://github.com/m-labs/nmigen.git
pip install git+https://github.com/m-labs/nmigen-boards.git
&lt;/code>&lt;/pre>&lt;p>安裝之後就可以開始學習如何使用nMigen製作電路&lt;/p>
&lt;h1 id="value-in-migen">Value in migen&lt;/h1>
&lt;h2 id="const-永不變">Const 永不變&lt;/h2>
&lt;pre>&lt;code>from nmigen import *
a = Const(10)
a.shape()
&amp;gt;&amp;gt; Shape(width=4, signed=False)
a = Const(10)
a.shape()
&amp;gt;&amp;gt; Shape(width=5, signed=True)
x = Const(3,range(-5,11))
x.shape()
&amp;gt;&amp;gt; Shape(width=5, signed=True)
&lt;/code>&lt;/pre>&lt;h2 id="可以使用enum-來做常數狀態">可以使用Enum 來做常數狀態&lt;/h2>
&lt;pre>&lt;code>from enum import Enum, unique
@unique
class Func(Enum):
NONE = 0
ADD = 1
SUB = 2
MUL = 3
DIV = 4
...
&amp;gt;&amp;gt;&amp;gt; x = Const(2, Func)
&amp;gt;&amp;gt;&amp;gt; x.shape()
unsigned(3)
&amp;gt;&amp;gt;&amp;gt; x = Value.cast(Func.NONE)
&amp;gt;&amp;gt;&amp;gt; x
const 3'd0
&lt;/code>&lt;/pre>&lt;h2 id="signal-是-wire或者reg">Signal 是 Wire或者reg&lt;/h2>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; from nmigen import *
&amp;gt;&amp;gt;&amp;gt; A = Signal(signed(8))
&amp;gt;&amp;gt;&amp;gt; A.shape()
Shape(width=8, signed=True)
&lt;/code>&lt;/pre>&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; x = Signal(range(-5,11))
&amp;gt;&amp;gt;&amp;gt; x.shape()
Shape(width=5, signed=True)
&lt;/code>&lt;/pre>&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; x = Signal(Func)
&amp;gt;&amp;gt;&amp;gt; x
(sig x)
&amp;gt;&amp;gt;&amp;gt; x = Signal(unsigned(16),name=&amp;quot;dout&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; x.name
'dout'
&lt;/code>&lt;/pre>&lt;hr>
&lt;blockquote>
&lt;p>但是我安裝Miniconda 後整個WSL的ssl都掛了，建議不要安裝&lt;/p>
&lt;h1 id="安裝miniconda">安裝Miniconda&lt;/h1>
&lt;p>因為我是用WSL，也沒有GUI，就直接用miniconda就好了。&lt;/p>
&lt;pre>&lt;code>wget https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Linux-x86_64.sh
chmod +x Miniconda3-py39_4.9.2-Linux-x86_64.sh
./Miniconda3-py39_4.9.2-Linux-x86_64.sh
&lt;/code>&lt;/pre>&lt;/blockquote></description></item></channel></rss>