[{"categories":null,"content":"Domains A domain in its basic definition, is a grouping of logic cells. If consider a module as a blackbox. With its inputs and outputs, any given output is generated within one and only one domain.\nModules come with two domain built in: a combinational domain and a sequential(synchronous) domain.\nCombinational Logic that contains no clocked elements is called combinational logic. This is one of the domain that a Module contains. It is always named comb, and it can be accessed via m.d.comb.\nm means Module and d means domain.\nSynchronous Logic that contains clocked elements is called synchronous (a.k.a sequential circuit) because all the FFs are triggered by particular clock domain. Each clock domain also has a reset signal which can reset all FFs to a given state. Finally, the domain specifies the edge of its clock on which all the FFs change: posedge or negedge.\nUnless otherwise specified, there is one synchronous domain in a Module called sync. It can be accessed via m.d.sync.\nCreating more domains There is no reason to create combinational domains. As mentioned above, modules already contain one combinational domain, comb.\nYou can create a synchronous clock domain using ClockDomain(\"\u003cdomain-name\u003e\", clk_edge=\"pos|neg\"). This gives you both the clock and the reset signal for the domain. By default, the domain name is sync and the clock edge is pos.\nm = Module() mydomain = ClockDomain(\"clk\") m.domains += mydomain m.d.mydomain += ... # logic to add in the \"mydomain\" clock domain. You can access a domain within a module by its name. So a domain created via ClockDomain(“my clock”) is accessed via m.d.myclock or m.d[\"myclk\"]. \\\n ClockSignal(domain=\"\u003cdomain\u003e\") gives you the clock signal for the given domain. ResetSignal(domain=\"\u003cdomain\u003e\") gives you the reset signal for the given domain.  Tips: Clock domains with the same clock but different edges. This can be done simply by creating one clockdomain\npos = ClockDomain(\"pos\") neg = ClockDomain(\"neg\", clk_edge=\"neg\") Next, assign them with same clock driven\nneg.clk = pos.clk neg.rst = pos.rst And then you can add these to the module. We can add more than domain to a module with the same statement.\nm.domains += [pos, neg] Access to domains A module can access its domains via its d attribute. By default, if a synchronous domain is added to a module’s domain, then all modules everywhere will also have access to that domain via their d attribute, even if that module is not a submodule of the module where the domain was added.\nm = Module() m2 = Module() m.domains += ClockDomain(\"thing\") m.d.thing += # logic # This is implicity m2.d.thing += #logic If you want to explicitly inhibit this global propagation by setting the local named parameter of the ClockDomain to True.\nm = Module() m2 = Module() m.domains += ClockDomain(\"thing\", local=True) m.d.thing += # logic # Error will occur here. m2.d.thing += # logic Ports The equivalent of ports in a module is public attributes. In the following example, a and data are publicly available to other modules, while b is not, just as a and data are publicly available to other python classes, and b is not.\nclass ThingBlock(Elaboratable): def __init__(self): # Public accessible self.a = Signal() self.data = Signal(8) def elaborate(self, platform: str): m = Module() # Internal use reg/wire. b = Signal() return m Reset/default values for signals If a Signal is set in the combinational or synchronous domain, then you can specify the default value of the signal if it is not set. By default value of the signal if it is not set. By default, it is zero, but for a non-zero value, you can specify the default value for a signal when constructing the signal by setting the reset named parameter in the constructor. For example, this create a 16-bit signed signal, self.x, which initial value set to 0xFFFF.\nself.x = Signal(signed(16), reset=0xFFFF) # initial value \"0xFFFF\" Explicitly not resetting For synchronous signals(that is, a signal set in a synchronous domain), you can specify that it is not reset on the reset signal, instead only getting an initial balue on power-up. This is done by setting the reset_less named parameter in the constructor to True\nself.x = Signal(signed(16),reset= 0xFFFF, reset_less = True) This is especially useful during simulation or formal verification where you want to activate the reset, but keep some signals “outside” the reset. For example, a cycle counter that maintains its count across resets.\nBasic operations Statements nMigen doesn’t convert Python to hardware. In essence, what you are writing using nMigen is a generator of logic, not the logic itself. So if you want to assign one Value to take the value of another, you don’t write a = b, but instead you call the method of a that generates the equality: a.eq(b). This is known as a statement.\nHowever, many math operators are overridable in Python, since these translate to calls to Python functions. So for example, you can write a.eq(b+1) instead of something like a.eq(b.plus(1)) because Python addition can be overrideen to a function callm and nMigen’s Signal class does that for all such operators (= is still not overrided).\nList of directly translatable Python operators    Operator Operation Notes     ~ inversion    - arithmetic negation    + addition    * multiplication    % modulus    // division integer division, rounding down   \u003c\u003c shift left    \u003e\u003e shift right Effectively arithmetic, see below.   \u0026 bitwise and    ` ` bitwise or   ^ bitwise xor    == equality    != inequality    \u003e greater than    \u003e= greater than or equal to    \u003c less than    \u003c= less than equal to      Note that there are no translatable Python logical operators (and,or). The logical reduction functions any and all are not avaliable in nMigen expressions.\nAttemped to convert nMigen value to boolean error will occur.\n  Shift right is effectively arithmetic, where the sign bit is present for signed values or zero for unsigned Values.\n ","description":"","tags":null,"title":"[Day02] Basic terminology","uri":"/posts/day02/"},{"categories":null,"content":"Basic structure of modules The tutorial is followed by https://github.com/RobertBaruch/nmigen-tutorial/ Thumbs up for his contributions.\nfrom nmigen import * from nmigen.build import Platform class ThingBlock(Elaboratable): def __init__(self): pass def elaborate(self, platform: Platform) -\u003e Module: m = Module() return m Elaborating a module from nmigen.cli import main if __name__== \"__main__\": sync = ClockDomain() block = ThingBlock() m = Module() m.domains += sync m.submodules += block main(m, ports=[sync.clk,sync.rst])  main(module, ports=[], platform=\"\") translate the given module into verilog. This is call elaboration. All elaborate() medthod will have its platform argument set to the given platform like particular chips or evaluation boards.  python3 thing.py generate -t [v|il] \u003e thing.[v|il]  If you encounter any error message, Back to day00 and install the pre-requisties.\n  Choose RTLIL if using yosys.  ","description":"","tags":null,"title":"[Day01] Basic nMigen","uri":"/posts/day01/"},{"categories":null,"content":"第一天接觸nMigen, 先來安裝　nMigen! 安裝Prerequisites sudo apt-get install build-essential clang bison flex libreadline-dev \\ gawk tcl-dev libffi-dev git mercurial graphviz \\ xdot pkg-config python python3 libftdi-dev gperf \\ libboost-program-options-dev autoconf libgmp-dev \\ cmake 安裝有的沒的必備程式 參考 https://symbiyosys.readthedocs.io/en/latest/install.html\n安裝nMigen pip install git+https://github.com/m-labs/nmigen.git pip install git+https://github.com/m-labs/nmigen-boards.git 安裝之後就可以開始學習如何使用nMigen製作電路\nValue in migen Const 永不變 from nmigen import * a = Const(10) a.shape() \u003e\u003e Shape(width=4, signed=False) a = Const(10) a.shape() \u003e\u003e Shape(width=5, signed=True) x = Const(3,range(-5,11)) x.shape() \u003e\u003e Shape(width=5, signed=True) 可以使用Enum 來做常數狀態 from enum import Enum, unique @unique class Func(Enum): NONE = 0 ADD = 1 SUB = 2 MUL = 3 DIV = 4 ... \u003e\u003e\u003e x = Const(2, Func) \u003e\u003e\u003e x.shape() unsigned(3) \u003e\u003e\u003e x = Value.cast(Func.NONE) \u003e\u003e\u003e x const 3'd0 Signal 是 Wire或者reg \u003e\u003e\u003e from nmigen import * \u003e\u003e\u003e A = Signal(signed(8)) \u003e\u003e\u003e A.shape() Shape(width=8, signed=True) \u003e\u003e\u003e x = Signal(range(-5,11)) \u003e\u003e\u003e x.shape() Shape(width=5, signed=True) \u003e\u003e\u003e x = Signal(Func) \u003e\u003e\u003e x (sig x) \u003e\u003e\u003e x = Signal(unsigned(16),name=\"dout\") \u003e\u003e\u003e x.name 'dout'   但是我安裝Miniconda 後整個WSL的ssl都掛了，建議不要安裝\n安裝Miniconda 因為我是用WSL，也沒有GUI，就直接用miniconda就好了。\nwget https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Linux-x86_64.sh chmod +x Miniconda3-py39_4.9.2-Linux-x86_64.sh ./Miniconda3-py39_4.9.2-Linux-x86_64.sh  ","description":"","tags":null,"title":"[Day00] nMigen 戰鬥","uri":"/posts/day00/"}]