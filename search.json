[{"categories":null,"content":"iCESugar-pro Offical github site: https://github.com/wuxx/icesugar-pro\nInstall Project Trellis The FPGA use EPC5 chips from lattice. We can use Trellis+ yosys+ nextpnr to develope our design. https://github.com/SymbiFlow/prjtrellis\nThis section will takes more than an hour to make it all done.\nInstall the dependencies for Project Trellis Install Boost 1 2 3  sudo apt-get install libboost-all-dev sudo apt install build-essential libboost-system-dev libboost-thread-dev libboost-program-options-dev libboost-test-dev sudo apt install libboost-filesystem1.71-dev   Install cmake 1  sudo apt install cmake   Install gcc-9 1  sudo apt install gcc-9   Install Eigen3 1  sudo apt-get install libeigen3-dev   Install Project trellis 1 2 3 4 5  git clone --recursive https://github.com/YosysHQ/prjtrellis cd prjtrellis/libtrellis cmake -DCMAKE_INSTALL_PREFIX=/usr . make sudo make install   Install nextpnr 1 2 3 4 5  git clone https://github.com/YosysHQ/nextpnr cd nextpnr cmake . -DARCH=ecp5 -DTRELLIS_INSTALL_PREFIX=/usr . make -j$(nproc) sudo make install   This step takes long time to make, especially large ram usage. If failed, you can see https://github.com/YosysHQ/nextpnr/issues/115 for more detailed build information.\nBuild a program for FPGAs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  import os import subprocess from typing import List from nmigen import Elaboratable, Module, Signal from nmigen.build import * from nmigen.build.run import LocalBuildProducts from nmigen.cli import main_parser, main_runner from nmigen.vendor.lattice_ecp5 import * class Blinker(Elaboratable): def __init__(self): pass def elaborate(self, platform: Platform) -\u003e Module: led = platform.request(\"led\", 0) timer = Signal(20) m = Module() m.d.sync += timer.eq(timer + 1) m.d.comb += led.o.eq(timer[-1]) return m def ports(self) -\u003e List[Signal]: return [] class Board(LatticeECP5Platform): device = \"LFE5U-25F\" package = \"BG256\" speed = \"6\" default_clk = \"clk1\" default_rst = \"rst\" resources = [ Resource(\"clk1\", 0, Pins(\"P6\",dir=\"i\"), Clock(25e6), Attrs(IO_TYPE = \"LVCMOS33\")), Resource(\"rst\", 0, Pins(\"L14\",dir=\"i\"), Attrs(IO_TYPE = \"LVCMOS33\")), Resource(\"led\", 0, Pins(\"B11\",dir=\"o\"), Attrs(IO_TYPE = \"LVCMOS33\")), ] connectors = [] def toolchain_program(self, products, name): iceprog = os.environ.get(\"ICEPROG\", \"iceprog\") with products.extract(\"{}.bin\".format(name)) as bitstream_filename: subprocess.check_call([iceprog, bitstream_filename]) if __name__ == \"__main__\": Board().build(Blinker(), do_program= False)    Note: In EPC5, IO_STANDARD is IO_TYPE and GLOBAL is not used.  python3 blinky.py Yosys report In the build folder under python file directory, here is the tree structure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  . ├── build_top.bat ├── build_top.sh ├── top.bit ├── top.config ├── top.debug.v ├── top.il ├── top.json ├── top.lpf ├── top.rpt ├── top.svf ├── top.tim └── top.ys 0 directories, 12 files   In top.rpt, you can see the report for FPGA utilization.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  === top === Number of wires: 23 Number of wire bits: 99 Number of public wires: 23 Number of public wire bits: 99 Number of memories: 0 Number of memory bits: 0 Number of processes: 0 Number of cells: 37 CCU2C 10 LUT4 1 SGSR 1 TRELLIS_FF 22 TRELLIS_IO 3   The number of cells is not nessecarily relevant to the code quality. Maybe you change something that you don’t think it will impact any design but it does. There is some randomness in synthesis.\nIn top.tim, you can check timing.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260  Info: constraining clock net 'clk1_0__io' to 25.00 MHz Info: Logic utilisation before packing: Info: Total LUT4s: 21/24288 0% Info: logic LUTs: 1/24288 0% Info: carry LUTs: 20/24288 0% Info: RAM LUTs: 0/12144 0% Info: RAMW LUTs: 0/ 6072 0% Info: Total DFFs: 44/24288 0% Info: Packing IOs.. Info: rst_0__io feeds TRELLIS_IO pin_rst_0.rst_0_0, removing $nextpnr_ibuf rst_0__io. Info: pin 'pin_rst_0.rst_0_0' constrained to Bel 'X72/Y32/PIOC'. Info: led_0__io feeds TRELLIS_IO pin_led_0.led_0_0, removing $nextpnr_obuf led_0__io. Info: pin 'pin_led_0.led_0_0' constrained to Bel 'X49/Y0/PIOA'. Info: clk1_0__io feeds TRELLIS_IO pin_clk1_0.clk1_0_0, removing $nextpnr_ibuf clk1_0__io. Info: pin 'pin_clk1_0.clk1_0_0' constrained to Bel 'X0/Y47/PIOC'. Info: Packing constants.. Info: Packing carries... Info: Finding LUTFF pairs... Info: Packing LUT5-7s... Info: Finding LUT-LUT pairs... Info: Packing paired LUTs into a SLICE... Info: Packing unpaired LUTs into a SLICE... Info: Packing unpaired FFs into a SLICE... Info: Generating derived timing constraints... Info: Promoting globals... Info: promoting clock net cd_sync_clk1_0__i to global network Info: Checksum: 0xd8bc23f8 Info: Annotating ports with timing budgets for target frequency 12.00 MHz Info: Checksum: 0x2027cd80 Info: Device utilisation: Info: TRELLIS_SLICE: 16/12144 0% Info: TRELLIS_IO: 3/ 197 1% Info: DCCA: 1/ 56 1% Info: DP16KD: 0/ 56 0% Info: MULT18X18D: 0/ 28 0% Info: ALU54B: 0/ 14 0% Info: EHXPLLL: 0/ 2 0% Info: EXTREFB: 0/ 1 0% Info: DCUA: 0/ 1 0% Info: PCSCLKDIV: 0/ 2 0% Info: IOLOGIC: 0/ 128 0% Info: SIOLOGIC: 0/ 69 0% Info: GSR: 1/ 1 100% Info: JTAGG: 0/ 1 0% Info: OSCG: 0/ 1 0% Info: SEDGA: 0/ 1 0% Info: DTR: 0/ 1 0% Info: USRMCLK: 0/ 1 0% Info: CLKDIVF: 0/ 4 0% Info: ECLKSYNCB: 0/ 10 0% Info: DLLDELD: 0/ 8 0% Info: DDRDLL: 0/ 4 0% Info: DQSBUFM: 0/ 8 0% Info: TRELLIS_ECLKBUF: 0/ 8 0% Info: ECLKBRIDGECS: 0/ 2 0% Info: DCSC: 0/ 2 0% Info: Placed 4 cells based on constraints. Info: Creating initial analytic placement for 4 cells, random placement wirelen = 272. Info: at initial placer iter 0, wirelen = 112 Info: at initial placer iter 1, wirelen = 112 Info: at initial placer iter 2, wirelen = 112 Info: at initial placer iter 3, wirelen = 112 Info: Running main analytical placer. Info: at iteration #1, type TRELLIS_SLICE: wirelen solved = 112, spread = 114, legal = 119; time = 0.00s Info: HeAP Placer Time: 0.01s Info: of which solving equations: 0.00s Info: of which spreading cells: 0.00s Info: of which strict legalisation: 0.00s Info: Running simulated annealing placer for refinement. Info: at iteration #1: temp = 0.000000, timing cost = 9, wirelen = 119 Info: at iteration #3: temp = 0.000000, timing cost = 9, wirelen = 115 Info: SA placement time 0.00s Info: Max frequency for clock '$glbnet$cd_sync_clk1_0__i': 289.52 MHz (PASS at 25.00 MHz) Info: Max delay \u003casync\u003e -\u003e \u003casync\u003e : 4.68 ns Info: Max delay \u003casync\u003e -\u003e posedge $glbnet$cd_sync_clk1_0__i: 8.64 ns Info: Max delay posedge $glbnet$cd_sync_clk1_0__i -\u003e \u003casync\u003e : 6.41 ns Info: Slack histogram: Info: legend: * represents 1 endpoint(s) Info: + represents [1,1) endpoint(s) Info: [ 31364, 33877) |* Info: [ 33877, 36390) | Info: [ 36390, 38903) |********************* Info: [ 38903, 41416) | Info: [ 41416, 43929) | Info: [ 43929, 46442) | Info: [ 46442, 48955) | Info: [ 48955, 51468) | Info: [ 51468, 53981) | Info: [ 53981, 56494) | Info: [ 56494, 59007) | Info: [ 59007, 61520) | Info: [ 61520, 64033) | Info: [ 64033, 66546) | Info: [ 66546, 69059) | Info: [ 69059, 71572) | Info: [ 71572, 74085) | Info: [ 74085, 76598) | Info: [ 76598, 79111) |** Info: [ 79111, 81624) |* Info: Checksum: 0x607e8c2f Info: Routing globals... Info: routing clock net $glbnet$cd_sync_clk1_0__i using global 0 Info: Routing.. Info: Setting up routing queue. Info: Routing 58 arcs. Info: | (re-)routed arcs | delta | remaining| time spent | Info: IterCnt | w/ripup wo/ripup | w/r wo/r | arcs| batch(sec) total(sec)| Info: 58 | 0 58 | 0 58 | 0| 0.02 0.02| Info: Routing complete. Info: Router1 time 0.02s Info: Checksum: 0xe0791b74 Info: Critical path report for clock '$glbnet$cd_sync_clk1_0__i' (posedge -\u003e posedge): Info: curr total Info: 0.5 0.5 Source timer$next_CCU2C_S0_9$CCU2_SLICE.Q0 Info: 0.8 1.3 Net timer[0] budget 18.993000 ns (47,2) -\u003e (47,2) Info: Sink timer$next_CCU2C_S0_9$CCU2_SLICE.B0 Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.4 1.8 Source timer$next_CCU2C_S0_9$CCU2_SLICE.FCO Info: 0.0 1.8 Net timer$next_CCU2C_S0_4_COUT[1] budget 0.000000 ns (47,2) -\u003e (47,2) Info: Sink timer$next_CCU2C_S0_3$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 1.9 Source timer$next_CCU2C_S0_3$CCU2_SLICE.FCO Info: 0.0 1.9 Net timer$next_CCU2C_S0_4_COUT[3] budget 0.000000 ns (47,2) -\u003e (47,2) Info: Sink timer$next_CCU2C_S0_2$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 1.9 Source timer$next_CCU2C_S0_2$CCU2_SLICE.FCO Info: 0.0 1.9 Net timer$next_CCU2C_S0_4_COUT[5] budget 0.000000 ns (47,2) -\u003e (48,2) Info: Sink timer$next_CCU2C_S0_1$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 2.0 Source timer$next_CCU2C_S0_1$CCU2_SLICE.FCO Info: 0.0 2.0 Net timer$next_CCU2C_S0_4_COUT[7] budget 0.000000 ns (48,2) -\u003e (48,2) Info: Sink timer$next_CCU2C_S0$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 2.1 Source timer$next_CCU2C_S0$CCU2_SLICE.FCO Info: 0.0 2.1 Net timer$next_CCU2C_S0_4_COUT[9] budget 0.000000 ns (48,2) -\u003e (48,2) Info: Sink timer$next_CCU2C_S0_8$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 2.2 Source timer$next_CCU2C_S0_8$CCU2_SLICE.FCO Info: 0.0 2.2 Net timer$next_CCU2C_S0_4_COUT[11] budget 0.000000 ns (48,2) -\u003e (48,2) Info: Sink timer$next_CCU2C_S0_7$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 2.2 Source timer$next_CCU2C_S0_7$CCU2_SLICE.FCO Info: 0.0 2.2 Net timer$next_CCU2C_S0_4_COUT[13] budget 0.000000 ns (48,2) -\u003e (49,2) Info: Sink timer$next_CCU2C_S0_6$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 2.3 Source timer$next_CCU2C_S0_6$CCU2_SLICE.FCO Info: 0.0 2.3 Net timer$next_CCU2C_S0_4_COUT[15] budget 0.000000 ns (49,2) -\u003e (49,2) Info: Sink timer$next_CCU2C_S0_5$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.1 2.4 Source timer$next_CCU2C_S0_5$CCU2_SLICE.FCO Info: 0.0 2.4 Net timer$next_CCU2C_S0_4_COUT[17] budget 0.000000 ns (49,2) -\u003e (49,2) Info: Sink timer$next_CCU2C_S0_4$CCU2_SLICE.FCI Info: Defined in: Info: blinky.py:18 Info: /usr/local/bin/../share/yosys/ecp5/arith_map.v:63.22-63.23 Info: 0.4 2.8 Source timer$next_CCU2C_S0_4$CCU2_SLICE.F0 Info: 0.1 2.9 Net timer$next[18] budget 19.007999 ns (49,2) -\u003e (49,2) Info: Sink timer$next_CCU2C_S0_4$CCU2_SLICE.DI0 Info: Defined in: Info: blinky.py:15 Info: 0.0 2.9 Setup timer$next_CCU2C_S0_4$CCU2_SLICE.DI0 Info: 2.0 ns logic, 1.0 ns routing Info: Critical path report for cross-domain path '\u003casync\u003e' -\u003e '\u003casync\u003e': Info: curr total Info: 0.0 0.0 Source pin_clk1_0.clk1_0_0.O Info: 1.7 1.7 Net cd_sync_clk1_0__i budget 41.667000 ns (0,47) -\u003e (3,25) Info: Sink $gbuf$cd_sync_clk1_0__i.CLKI Info: Defined in: Info: /home/waxapple/.local/lib/python3.8/site-packages/nmigen/build/res.py:137 Info: 0.0 1.7 Source $gbuf$cd_sync_clk1_0__i.CLKO Info: 0.0 1.7 Net $glbnet$cd_sync_clk1_0__i budget 41.666000 ns (3,25) -\u003e (4,49) Info: Sink cd_sync.U$$2.CLK Info: 0.0 ns logic, 1.7 ns routing Info: Critical path report for cross-domain path '\u003casync\u003e' -\u003e 'posedge $glbnet$cd_sync_clk1_0__i': Info: curr total Info: 0.0 0.0 Source pin_rst_0.rst_0_0.O Info: 3.1 3.1 Net cd_sync_rst_0__i budget 19.882000 ns (72,32) -\u003e (21,33) Info: Sink cd_sync.rst_0__i_LUT4_D_SLICE.D1 Info: Defined in: Info: /home/waxapple/.local/lib/python3.8/site-packages/nmigen/build/res.py:137 Info: 0.2 3.3 Source cd_sync.rst_0__i_LUT4_D_SLICE.F1 Info: 0.1 3.5 Net cd_sync.U$$0_DI budget 19.882000 ns (21,33) -\u003e (21,33) Info: Sink cd_sync.rst_0__i_LUT4_D_SLICE.DI1 Info: Defined in: Info: /home/waxapple/.local/lib/python3.8/site-packages/nmigen/vendor/lattice_ecp5.py:334 Info: 0.0 3.5 Setup cd_sync.rst_0__i_LUT4_D_SLICE.DI1 Info: 0.2 ns logic, 3.2 ns routing Info: Critical path report for cross-domain path 'posedge $glbnet$cd_sync_clk1_0__i' -\u003e '\u003casync\u003e': Info: curr total Info: 0.5 0.5 Source cd_sync.U$$1_SLICE.Q0 Info: 3.0 3.5 Net cd_sync.gsr1 budget 82.807999 ns (21,33) -\u003e (4,49) Info: Sink cd_sync.U$$2.GSR Info: Defined in: Info: /home/waxapple/.local/lib/python3.8/site-packages/nmigen/vendor/lattice_ecp5.py:330 Info: 0.5 ns logic, 3.0 ns routing Info: Max frequency for clock '$glbnet$cd_sync_clk1_0__i': 340.48 MHz (PASS at 25.00 MHz) Info: Max delay \u003casync\u003e -\u003e \u003casync\u003e : 1.74 ns Info: Max delay \u003casync\u003e -\u003e posedge $glbnet$cd_sync_clk1_0__i: 3.45 ns Info: Max delay posedge $glbnet$cd_sync_clk1_0__i -\u003e \u003casync\u003e : 3.51 ns Info: Slack histogram: Info: legend: * represents 1 endpoint(s) Info: + represents [1,1) endpoint(s) Info: [ 36545, 38816) |********************* Info: [ 38816, 41087) |* Info: [ 41087, 43358) | Info: [ 43358, 45629) | Info: [ 45629, 47900) | Info: [ 47900, 50171) | Info: [ 50171, 52442) | Info: [ 52442, 54713) | Info: [ 54713, 56984) | Info: [ 56984, 59255) | Info: [ 59255, 61526) | Info: [ 61526, 63797) | Info: [ 63797, 66068) | Info: [ 66068, 68339) | Info: [ 68339, 70610) | Info: [ 70610, 72881) | Info: [ 72881, 75152) | Info: [ 75152, 77423) | Info: [ 77423, 79694) | Info: [ 79694, 81965) |*** Info: Program finished normally.   Program bitstream file into FPGA Wait for the FPGA arrives.\n","description":"","tags":null,"title":"[Day11]New toy iCESugar-Pro!","uri":"/posts/day11/"},{"categories":null,"content":"Cycle accurate simulation In previous session, we use combinational circuit design. Now, it is time for some sequential circuits!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  from typing import List from nmigen.asserts import Assert,Cover,Assume from nmigen import Elaboratable, Module, Signal, Mux from nmigen.back.pysim import Simulator, Delay from nmigen.build import Platform from nmigen.cli import main_parser, main_runner class Clocky(Elaboratable): def __init__(self): self.x = Signal(7) self.load = Signal() self.value = Signal(7) def elaborate(self, platform: Platform) -\u003e Module: m = Module() with m.If(self.load): m.d.sync += self.x.eq(Mux(self.value \u003c= 100, self.value, 100)) with m.Elif(self.x == 100): m.d.sync += self.x.eq(0) with m.Else(): m.d.sync += self.x.eq(self.x + 1) return m def ports(self) -\u003e List[Signal]: return [self.x, self.load, self.value] if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.clocky = clocky = Clocky() #main_runner(parser, args, m, ports=[] + clocky.ports()) load = Signal() value = Signal(7) m.d.comb += clocky.load.eq(load) m.d.comb += clocky.value.eq(value) sim = Simulator(m) sim.add_clock(1e-6) def process(): yield yield load.eq(1) yield value.eq(95) yield yield load.eq(0) yield yield yield yield yield yield yield yield yield sim.add_sync_process(process) with sim.write_vcd(\"test.vcd\", \"test.gtkw\", traces=[] + clocky.ports()): sim.run()   After simulation, here is the waveform. As you can see, x will be loaded when load is high and after the pulse, x will keep increasing each cycle until it reaches 100. Then x will be clear.\nYou might want to ask, why would x is not loaded at rising edge of load? That is becuase load is changing not simutanously with clock edge but infinitesimally close after clock rising edge. Which also applys to clock falling edge.\nFormal verification We remove simulator part and add main_runner into our clocky.py.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  from typing import List from nmigen.asserts import Assert,Cover,Assume,Past from nmigen import Elaboratable, Module, Signal, Mux from nmigen.back.pysim import Simulator, Delay from nmigen.build import Platform from nmigen.cli import main_parser, main_runner class Clocky(Elaboratable): def __init__(self): self.x = Signal(7) self.load = Signal() self.value = Signal(7) def elaborate(self, platform: Platform) -\u003e Module: m = Module() with m.If(self.load): m.d.sync += self.x.eq(Mux(self.value \u003c= 100, self.value, 100)) with m.Elif(self.x == 100): m.d.sync += self.x.eq(0) with m.Else(): m.d.sync += self.x.eq(self.x + 1) return m def ports(self) -\u003e List[Signal]: return [self.x, self.load, self.value] if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.clocky = clocky = Clocky() with m.If((clocky.x \u003e 0)): m.d.sync += Assert(clocky.x == (Past(clocky.x) + 1)[:7]) main_runner(parser, args, m, ports=[] + clocky.ports())   Generate toplevel iLang file and sby file.\n1  python3 clocky.py generate -t il \u003e toplevel.il   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [tasks] cover bmc [options] bmc: mode bmc cover: mode cover depth 40 multiclock off [engines] smtbmc boolector [script] read_ilang toplevel.il prep -top top [files] toplevel.il   1  sby -f clocky.sby    Note: use depth 40 which means to run 40 cycles. The result will be: It Failed on bmc test! Why? We can trace the bmc waveform.  gtkwave.exe clocky_bmc/engine_0/trace.vcd \u0026 Yes, in formal verification, it found that Past(x) is 0x00 and x is 0x4A which violates the rule!\nHere we change the condition into:\n1 2 3 4 5 6 7 8 9  if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.clocky = clocky = Clocky() with m.If((clocky.x \u003e 0) \u0026 (Past(clocky.load) == 0)): m.d.sync += Assert(clocky.x == (Past(clocky.x) + 1)[:7]) main_runner(parser, args, m, ports=[] + clocky.ports())   Assertion will only applied if x \u003e 0 \u0026 Past(load) == 0. After changing, it will pass the bmc test. Here is another interesting case. We put a assertion like this:\n1 2 3 4 5 6 7 8 9 10 11  if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.clocky = clocky = Clocky() with m.If((clocky.x \u003e 0) \u0026 (Past(clocky.load) == 0)): m.d.sync += Assert(clocky.x == (Past(clocky.x) + 1)[:7]) with m.If(clocky.x == 0): m.d.sync += Assert(Past(clocky.x) == 100) main_runner(parser, args, m, ports=[] + clocky.ports())   This statement is not always true if x start with 0x00 at 0 ns. But who knows? Let’s fire formal verification up!\npython3 clocky.py generate -t il \u003e toplevel.il sby -f clocky.sby Oh, it discoverd our little secret! Let’s take a look into trace waveform.\ngtkwave.exe clocky_bmc/engine_0/trace.vcd \u0026 Wow! It actually discovers a specific case that we just talked about. x begins with 0 initial value!\nOkie, how about we say only checks this condition under Past(rst) == 0?\n1 2 3 4 5 6 7 8 9 10 11 12 13  if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.clocky = clocky = Clocky() rst = ResetSignal() with m.If((clocky.x \u003e 0) \u0026 (Past(clocky.load) == 0)): m.d.sync += Assert(clocky.x == (Past(clocky.x) + 1)[:7]) with m.If((clocky.x == 0) \u0026 (Past(rst) == 0) ): m.d.sync += Assert(Past(clocky.x) == 100) main_runner(parser, args, m, ports=[] + clocky.ports())   The answer is …still no!\nAs you can see, you must be very careful about condtion in formal verification especially in a complex design.\nHere is the correct condition:\n1 2 3 4 5 6 7 8 9 10 11 12 13  if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.clocky = clocky = Clocky() rst = ResetSignal() with m.If((clocky.x \u003e 0) \u0026 (Past(clocky.load) == 0)): m.d.sync += Assert(clocky.x == (Past(clocky.x) + 1)[:7]) with m.If((clocky.x == 0) \u0026 (Past(rst) == 0) \u0026 (Past(clocky.load) == 0)): m.d.sync += Assert(Past(clocky.x) == 100) main_runner(parser, args, m, ports=[] + clocky.ports())   And here is the result: ","description":"","tags":null,"title":"[Day10] Clock domain simulation!","uri":"/posts/day10/"},{"categories":null,"content":"Perform formal verification What is a “formal verification” ?\nFormal verification is a process of checking whether a design satisfies some requirements.\nExample Here is an adder. It is different from previous one on day 8. In order to make sure the adder in the design satisfies “addition”. We use assertion to varify the design.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  from typing import List from nmigen.asserts import Assert from nmigen import Elaboratable, Module, Signal from nmigen.back.pysim import Simulator, Delay from nmigen.build import Platform from nmigen.cli import main_parser, main_runner class Adder(Elaboratable): def __init__(self): self.x = Signal(8) self.y = Signal(8) self.out = Signal(8) def elaborate(self, paltform: Platform) -\u003e Module: m = Module() m.d.comb += self.out.eq(self.x + self.y) return m def ports(self) -\u003e List[Signal]: return [self.x, self.y, self.out] if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() m.d.comb += Assert(adder.out == adder.x + adder.y) main_runner(parser, args, m, ports=[] + adder.ports()) # x = Signal(8) # y = Signal(8) # m.d.comb += adder.x.eq(x) # m.d.comb += adder.y.eq(y) # sim = Simulator(m) # def process(): # yield x.eq(0x00) # yield y.eq(0x00) # yield Delay(1e-6) # yield x.eq(0xFF) # yield y.eq(0xFF) # yield Delay(1e-6) # yield x.eq(0x00) # yield Delay(1e-6) # sim.add_process(process) # with sim.write_vcd(\"test.vcd\", \"test.gtkw\", traces=[x, y] + adder.ports()): # sim.run() # print(\"end of code\")   Generate iLang file python3 adder.py generate -t il \u003e toplevel.il It will generate toplevel.il under working directory path.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  attribute \\generator \"nMigen\" attribute \\nmigen.hierarchy \"top.adder\" module \\adder attribute \\src \"adder.py:12\" wire width 8 output 0 \\out attribute \\src \"adder.py:10\" wire width 8 input 1 \\x attribute \\src \"adder.py:11\" wire width 8 input 2 \\y attribute \\src \"adder.py:17\" wire width 9 $1 attribute \\src \"adder.py:17\" wire width 9 $2 attribute \\src \"adder.py:17\" cell $add $3 parameter \\A_SIGNED 1'0 parameter \\A_WIDTH 4'1000 parameter \\B_SIGNED 1'0 parameter \\B_WIDTH 4'1000 parameter \\Y_WIDTH 4'1001 connect \\A \\x connect \\B \\y connect \\Y $2 end connect $1 $2 process $group_0 assign \\out 8'00000000 assign \\out $1 [7:0] sync init end end attribute \\generator \"nMigen\" attribute \\top 1 attribute \\nmigen.hierarchy \"top\" module \\top attribute \\src \"adder.py:10\" wire width 8 input 0 \\x attribute \\src \"adder.py:11\" wire width 8 input 1 \\y attribute \\src \"adder.py:12\" wire width 8 output 2 \\out cell \\adder \\adder connect \\out \\out connect \\x \\x connect \\y \\y end attribute \\src \"adder.py:27\" wire width 1 $assert$en attribute \\src \"adder.py:27\" wire width 1 $assert$check attribute \\src \"adder.py:27\" wire width 9 $1 attribute \\src \"adder.py:27\" cell $add $2 parameter \\A_SIGNED 1'0 parameter \\A_WIDTH 4'1000 parameter \\B_SIGNED 1'0 parameter \\B_WIDTH 4'1000 parameter \\Y_WIDTH 4'1001 connect \\A \\x connect \\B \\y connect \\Y $1 end attribute \\src \"adder.py:27\" wire width 1 $3 attribute \\src \"adder.py:27\" cell $eq $4 parameter \\A_SIGNED 1'0 parameter \\A_WIDTH 4'1000 parameter \\B_SIGNED 1'0 parameter \\B_WIDTH 4'1001 parameter \\Y_WIDTH 1'1 connect \\A \\out connect \\B $1 connect \\Y $3 end attribute \\src \"adder.py:27\" cell $assert $5 connect \\A $assert$check connect \\EN $assert$en end process $group_0 assign $assert$en 1'0 assign $assert$check 1'0 assign $assert$check $3 assign $assert$en 1'1 sync init end end   A sby file for formal verification 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [tasks] cover bmc [options] bmc: mode bmc cover: mode cover depth 2 multiclock off [engines] smtbmc boolector [script] read_ilang toplevel.il prep -top top [files] toplevel.il   We will talk about the settings later. Fire the thing up.\nsby -f adder.sby As you can see, cover test passed but bmc test failed. We can trace it by firing\ngtkwave.exe adder_bmc/engine_0/trace.vcd But yes, 0xFF + 0x01 == 0x00. What is the deal with it? Well, in assertion, we didn’t truncate the signal which makes it 8-bit verse 9-bit signal. Here is how we fix our design.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  from typing import List from nmigen.asserts import Assert from nmigen import Elaboratable, Module, Signal from nmigen.back.pysim import Simulator, Delay from nmigen.build import Platform from nmigen.cli import main_parser, main_runner class Adder(Elaboratable): def __init__(self): self.x = Signal(8) self.y = Signal(8) self.out = Signal(8) def elaborate(self, paltform: Platform) -\u003e Module: m = Module() m.d.comb += self.out.eq(self.x + self.y) return m def ports(self) -\u003e List[Signal]: return [self.x, self.y, self.out] if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() # Truncated m.d.comb += Assert(adder.out == (adder.x + adder.y)[:8]) main_runner(parser, args, m, ports=[] + adder.ports())   And now the verification result will be correct:  Note: If you get error message like “no boolector found”, go back to day one and install it properly.\n Cover function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  from typing import List from nmigen.asserts import Assert,Cover from nmigen import Elaboratable, Module, Signal from nmigen.back.pysim import Simulator, Delay from nmigen.build import Platform from nmigen.cli import main_parser, main_runner class Adder(Elaboratable): def __init__(self): self.x = Signal(8) self.y = Signal(8) self.out = Signal(8) def elaborate(self, paltform: Platform) -\u003e Module: m = Module() m.d.comb += self.out.eq(self.x + self.y) return m def ports(self) -\u003e List[Signal]: return [self.x, self.y, self.out] if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() m.d.comb += Assert(adder.out == (adder.x + adder.y)[:8]) m.d.comb += Cover(adder.out == 0xFF) m.d.comb += Cover((adder.out == 0xFE) \u0026 (adder.x == 0xFE)) main_runner(parser, args, m, ports=[] + adder.ports())   Recompile it and run formal verification. There is two trace file, let’s take a look.\ngtkwave.exe adder_cover/engine_0/trace0.vcd \u0026 This is the case one, out == 0xFF\ngtkwave.exe adder_cover/engine_0/trace1.vcd \u0026 This is the case two, out == 0xFE and x == 0xFE. Any cover event is independant to any other cover events.\nAssumuption Assumption is to assume a signal that is not being a illegal state and the signal will always satisfy specific assumptions.\n1 2 3 4 5 6 7 8 9 10 11  ... if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() m.d.comb += Assert(adder.out == (adder.x + adder.y)[:8]) m.d.comb += Assume(adder.x == (adder.y \u003c\u003c1)) m.d.comb += Cover((adder.out \u003e 0x00) \u0026 (adder.out \u003c 0x40)) main_runner(parser, args, m, ports=[] + adder.ports())   Here we assume x is always equal to y \u003c\u003c 1. And find one case for output ranges between 0x00 and 0x40. We can do some interesting stuff like:\n1 2 3 4 5 6 7 8 9 10  if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() m.d.comb += Assert(adder.out == (adder.x + adder.y)[:8]) with m.If(adder.x == (adder.y \u003c\u003c1)): m.d.comb += Cover((adder.out \u003e 0x00) \u0026 (adder.out \u003c 0x40)) main_runner(parser, args, m, ports=[] + adder.ports())   Which means cover the output range if x == y\u003c\u003c1. ","description":"","tags":null,"title":"[Day09] Formal verification on adder","uri":"/posts/day09/"},{"categories":null,"content":"Prerequisites If you would like to perform simulation with GTKwave, a opensource free waveform viewer. Download the software here\nand put it under C:/gtkwave. Go to the windows path setting and add it under the $path variable.\nThe main function We create a simple 8-bit adder\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  from typing import List from nmigen import Elaboratable, Module, Signal from nmigen.back.pysim import Simulator, Delay from nmigen.build import Platform from nmigen.cli import main_parser, main_runner class Adder(Elaboratable): def __init__(self): self.x = Signal(8) self.y = Signal(8) self.out = Signal(8) def elaborate(self, paltform: Platform) -\u003e Module: m = Module() m.d.comb += self.out.eq(self.x + self.y) return m def ports(self) -\u003e List[Signal]: return [self.x, self.y, self.out] if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() # main_runner(parser, args, m, ports=[] + adder.ports()) x = Signal(8) y = Signal(8) m.d.comb += adder.x.eq(x) m.d.comb += adder.y.eq(y) sim = Simulator(m) def process(): yield x.eq(0x00) yield y.eq(0x00) yield Delay(1e-6) yield x.eq(0xFF) yield y.eq(0xFF) yield Delay(1e-6) yield x.eq(0x00) yield Delay(1e-6) sim.add_process(process) with sim.write_vcd(\"test.vcd\", \"test.gtkw\", traces=[x, y] + adder.ports()): sim.run() print(\"end of code\")   Run the simulation python3 adder.py Remember to type python3!\nGet the simulation waveform from GTKwave After firing simulator, it will generate a file call test.vcd.\ngtkwave.exe test.vcd \u0026 The GTKwave will pop up and click adder on the left. Select the signals and right click \u003e recurse import \u003e append. ","description":"","tags":null,"title":"[Day08] First fight with nMigen on simply an adder!","uri":"/posts/day08/"},{"categories":null,"content":"Supported devices See the vendor directory for supported devices and toolchain details.\nDevices supported as of 18 JUL 2021:\n   Device Platform Toolchain required     Lattice iCE40  Yosys+nextpnr, LSE-iCECube2, Synplify-iCECube2   Lattice MachXO2  Diamond   Lattice ECP5  Yosys+nextpnr, Diamond   Xilinx Spartan 3A Xilinx ISE   Xilinx Spartan 6 Xilinx ISE   Xilinx 7-series (Arty, Spartan, Kintex, Virtex) Xilinx Vivado   Xilinx UltraScale XilinxUltraScalePlatform Vivado   Intel IntelPlatform Quartus    Defining your board Many boards are defined for you at nmigen_boards.\nYou can copy one from there and modify it to suit you needs, or create a new class subclassed from one of the above supported device platform classes. For example, I am using Xilinx-KC705 for my development.\nClass properties  device: a string. See the base platform class for which one to choose. This affects options passed to the toolchain so that it compiles for the correct chip. package: a string. See the base platform class for which one to choose. This affects options passed to the toolchain so that it compiles for the correct package of the chip. resources: a list of Resource. This names the pins you want to use, and configuration options for each such pin. default_clk: the name of the resource that is the clock for the default clock domain. default_rst: the name of the resource that is the reset for the default clock domain. connectors: optional, a list of Connector. It isn’t obvious what purpose this serves. It may have something to do with certain toolchains.  Resources A Resource is a structure that contains a name, a number, and one or more configuration items for the resource. Adding a Resource to a board does two things:\n configures pin on the device allows you to request a resource’s pin by name from the platform in your elaborate function.Such a pin has several signal associated with it, such as i for input and o for output, which you can then use in your module.  For example, by including this Resource into the platform’s resource list:\nResource(\"abc\", 0, Pins(\"J3\", dir=\"i\")) Then pin J3 on the device will be configured as an input, and you can request the abc resource’s input Signal like this\nplatform.request(\"abc\").i Resource configuration items  Pins: specifies the space-separated pin names associated with resource, their direction type, and whether the signal should be automativally inverted when crossing the pin(for, e.g., active low signals). Direction types are:    i: input only. Signal for the pin is .i o: output only. Signal for the pin is .o io: bidirectional. Signals for the pin are .o for the output, and .oe is the direction for the pin: 0 for input, 1 for output. oe: tristate. Signals for the pin .o for the output, and .oe to enable output: 0 for disable, 1 for enable.    PinsN: shorthand for Pins, where all pins are active low. DiffPairs: specifies the space-separated pin names for one or more differential pairs (positive and negative pins) Clock: specifies that the resource is a clock with the given frequency in Hz. Attrs: platform-specific attributes such as voltage standard to select.  A full resource specification for a clock pin used on a Lattice ICE40 board could be as follows:\nResource(\"clk\", 0, Pins(\"J3\",dir=\"i\"), Clock(12e6),Attrs(GLOBAL=True, IO_STANDARD=\"SB_LVCMOS\")) This example says that the clk resource is at pin J3 on the FPGA. J3 is defined by vender of your FPGA. For example, KC705 pin map can be found at here. clk has a frequency of 12MHz, is a “global” signal, and uses the LVCMOS voltage standard. Without knowing about the toolchain for the platform, you will not know what attributes are required.\nExample for the Xilinx-KC705. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  import os import subprocess from nmigen.build import * from nmigen.vendor.xilinx_7series import * from .resources import * __all__ = [\"KC705Platform\"] class KC705Platform(Xilinx7SeriesPlatform): device = \"xc7k325t\" package = \"ffg900\" speed = \"2\" default_clk = \"clk156\" resources = [ Resource(\"clk156\", 0, DiffPairs(\"K28\", \"K29\", dir=\"i\"), Clock(156e6), Attrs(IOSTANDARD=\"LVDS_25\")), *LEDResources(pins=\"AB8 AA8 AC9 AB9 AE26 G19 E18 F16\", attrs=Attrs(IOSTANDARD=\"LVCMOS15\")), UARTResource(0, rx=\"M19\", tx=\"K24\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\") ), ] connectors = [] def toolchain_program(self, products, name): openocd = os.environ.get(\"OPENOCD\", \"openocd\") with products.extract(\"{}.bit\".format(name)) as bitstream_filename: subprocess.check_call([openocd, \"-c\", \"source [find board/kc705.cfg]; init; pld load 0 {}; exit\" .format(bitstream_filename) ]) if __name__ == \"__main__\": from .test.blinky import * KC705Platform().build(Blinky(), do_program=True)   You can see that it is not well define yet. Let’s take a look into arty-a7 board.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220  import os import subprocess from nmigen.build import * from nmigen.vendor.xilinx_7series import * from .resources import * __all__ = [\"ArtyA7Platform\"] class ArtyA7Platform(Xilinx7SeriesPlatform): device = \"xc7a35ti\" package = \"csg324\" speed = \"1L\" default_clk = \"clk100\" resources = [ Resource(\"clk100\", 0, Pins(\"E3\", dir=\"i\"), Clock(100e6), Attrs(IOSTANDARD=\"LVCMOS33\")), *LEDResources(pins=\"H5 J5 T9 T10\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), RGBLEDResource(0, r=\"G6\", g=\"F6\", b=\"E1\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), RGBLEDResource(1, r=\"G3\", g=\"J4\", b=\"G4\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), RGBLEDResource(2, r=\"J3\", g=\"J2\", b=\"H4\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), RGBLEDResource(3, r=\"K1\", g=\"H6\", b=\"K2\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), *ButtonResources(pins=\"D9 C9 B9 B8 \", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), *SwitchResources(pins=\"A8 C11 C10 A10\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\")), UARTResource(0, rx=\"A9\", tx=\"D10\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\") ), Resource(\"cpu_reset\", 0, Pins(\"C2\", dir=\"o\"), Attrs(IOSTANDARD=\"LVCMOS33\")), SPIResource(0, cs=\"C1\", clk=\"F1\", mosi=\"H1\", miso=\"G1\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\") ), Resource(\"i2c\", 0, Subsignal(\"scl\", Pins(\"L18\", dir=\"io\")), Subsignal(\"sda\", Pins(\"M18\", dir=\"io\")), Subsignal(\"scl_pullup\", Pins(\"A14\", dir=\"o\")), Subsignal(\"sda_pullup\", Pins(\"A13\", dir=\"o\")), Attrs(IOSTANDARD=\"LVCMOS33\") ), *SPIFlashResources(0, cs=\"L13\", clk=\"L16\", mosi=\"K17\", miso=\"K18\", wp=\"L14\", hold=\"M14\", attrs=Attrs(IOSTANDARD=\"LVCMOS33\") ), Resource(\"ddr3\", 0, Subsignal(\"rst\", PinsN(\"K6\", dir=\"o\")), Subsignal(\"clk\", DiffPairs(\"U9\", \"V9\", dir=\"o\"), Attrs(IOSTANDARD=\"DIFF_SSTL135\")), Subsignal(\"clk_en\", Pins(\"N5\", dir=\"o\")), Subsignal(\"cs\", PinsN(\"U8\", dir=\"o\")), Subsignal(\"we\", PinsN(\"P5\", dir=\"o\")), Subsignal(\"ras\", PinsN(\"P3\", dir=\"o\")), Subsignal(\"cas\", PinsN(\"M4\", dir=\"o\")), Subsignal(\"a\", Pins(\"R2 M6 N4 T1 N6 R7 V6 U7 R8 V7 R6 U6 T6 T8\", dir=\"o\")), Subsignal(\"ba\", Pins(\"R1 P4 P2\", dir=\"o\")), Subsignal(\"dqs\", DiffPairs(\"N2 U2\", \"N1 V2\", dir=\"io\"), Attrs(IOSTANDARD=\"DIFF_SSTL135\")), Subsignal(\"dq\", Pins(\"K5 L3 K3 L6 M3 M1 L4 M2 V4 T5 U4 V5 V1 T3 U3 R3\", dir=\"io\"), Attrs(IN_TERM=\"UNTUNED_SPLIT_40\")), Subsignal(\"dm\", Pins(\"L1 U1\", dir=\"o\")), Subsignal(\"odt\", Pins(\"R5\", dir=\"o\")), Attrs(IOSTANDARD=\"SSTL135\", SLEW=\"FAST\"), ), Resource(\"eth_clk25\", 0, Pins(\"G18\", dir=\"o\"), Clock(25e6), Attrs(IOSTANDARD=\"LVCMOS33\")), Resource(\"eth_clk50\", 0, Pins(\"G18\", dir=\"o\"), Clock(50e6), Attrs(IOSTANDARD=\"LVCMOS33\")), Resource(\"eth_mii\", 0, Subsignal(\"rst\", PinsN(\"C16\", dir=\"o\")), Subsignal(\"mdio\", Pins(\"K13\", dir=\"io\")), Subsignal(\"mdc\", Pins(\"F16\", dir=\"o\")), Subsignal(\"tx_clk\", Pins(\"H16\", dir=\"i\")), Subsignal(\"tx_en\", Pins(\"H15\", dir=\"o\")), Subsignal(\"tx_data\", Pins(\"H14 J14 J13 H17\", dir=\"o\")), Subsignal(\"rx_clk\", Pins(\"F15\", dir=\"i\")), Subsignal(\"rx_dv\", Pins(\"G16\", dir=\"i\"), Attrs(PULLDOWN=\"TRUE\")), # strap to select MII Subsignal(\"rx_er\", Pins(\"C17\", dir=\"i\")), Subsignal(\"rx_data\", Pins(\"D18 E17 E18 G17\", dir=\"i\")), Subsignal(\"col\", Pins(\"D17\", dir=\"i\")), Subsignal(\"crs\", Pins(\"G14\", dir=\"i\")), Attrs(IOSTANDARD=\"LVCMOS33\") ), Resource(\"eth_rmii\", 0, Subsignal(\"rst\", PinsN(\"C16\", dir=\"o\")), Subsignal(\"mdio\", Pins(\"K13\", dir=\"io\")), Subsignal(\"mdc\", Pins(\"F16\", dir=\"o\")), Subsignal(\"tx_en\", Pins(\"H15\", dir=\"o\")), Subsignal(\"tx_data\", Pins(\"H14 J14\", dir=\"o\")), Subsignal(\"rx_crs_dv\", Pins(\"G14\", dir=\"i\")), Subsignal(\"rx_dv\", Pins(\"G16\", dir=\"i\"), Attrs(PULLUP=\"TRUE\")), # strap to select RMII Subsignal(\"rx_er\", Pins(\"C17\", dir=\"i\")), Subsignal(\"rx_data\", Pins(\"D18 E17\", dir=\"i\")), Attrs(IOSTANDARD=\"LVCMOS33\") ) ] connectors = [ Connector(\"pmod\", 0, \"G13 B11 A11 D12 - - D13 B18 A18 K16 - -\"), # JA Connector(\"pmod\", 1, \"E15 E16 D15 C15 - - J17 J18 K15 J15 - -\"), # JB Connector(\"pmod\", 2, \"U12 V12 V10 V11 - - U14 V14 T13 U13 - -\"), # JC Connector(\"pmod\", 3, \" D4 D3 F4 F3 - - E2 D2 H2 G2 - -\"), # JD Connector(\"ck_io\", 0, { # Outer Digital Header \"io0\": \"V15\", \"io1\": \"U16\", \"io2\": \"P14\", \"io3\": \"T11\", \"io4\": \"R12\", \"io5\": \"T14\", \"io6\": \"T15\", \"io7\": \"T16\", \"io8\": \"N15\", \"io9\": \"M16\", \"io10\": \"V17\", \"io11\": \"U18\", \"io12\": \"R17\", \"io13\": \"P17\", # Inner Digital Header \"io26\": \"U11\", \"io27\": \"V16\", \"io28\": \"M13\", \"io29\": \"R10\", \"io30\": \"R11\", \"io31\": \"R13\", \"io32\": \"R15\", \"io33\": \"P15\", \"io34\": \"R16\", \"io35\": \"N16\", \"io36\": \"N14\", \"io37\": \"U17\", \"io38\": \"T18\", \"io39\": \"R18\", \"io40\": \"P18\", \"io41\": \"N17\", # Outer Analog Header as Digital IO \"a0\": \"F5\", \"a1\": \"D8\", \"a2\": \"C7\", \"a3\": \"E7\", \"a4\": \"D7\", \"a5\": \"D5\", # Inner Analog Header as Digital IO \"io20\": \"B7\", \"io21\": \"B6\", \"io22\": \"E6\", \"io23\": \"E5\", \"io24\": \"A4\", \"io25\": \"A3\" }), Connector(\"xadc\", 0, { # Outer Analog Header \"vaux4_n\": \"C5\", \"vaux4_p\": \"C6\", \"vaux5_n\": \"A5\", \"vaux5_p\": \"A6\", \"vaux6_n\": \"B4\", \"vaux6_p\": \"C4\", \"vaux7_n\": \"A1\", \"vaux7_p\": \"B1\", \"vaux15_n\": \"B2\", \"vaux15_p\": \"B3\", \"vaux0_n\": \"C14\", \"vaux0_p\": \"D14\", # Inner Analog Header \"vaux12_n\": \"B7\", \"vaux12_p\": \"B6\", \"vaux13_n\": \"E6\", \"vaux13_p\": \"E5\", \"vaux14_n\": \"A4\", \"vaux14_p\": \"A3\", # Power Measurements \"vsnsuv_n\": \"B17\", \"vsnsuv_p\": \"B16\", \"vsns5v0_n\": \"B12\", \"vsns5v0_p\": \"C12\", \"isns5v0_n\": \"F14\", \"isns5v0_n\": \"F13\", \"isns0v95_n\": \"A16\", \"isns0v95_n\": \"A15\", }) ] def toolchain_prepare(self, fragment, name, **kwargs): overrides = { \"script_before_bitstream\": \"set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]\", \"script_after_bitstream\": \"write_cfgmem -force -format bin -interface spix4 -size 16 \" \"-loadbit \\\"up 0x0 {name}.bit\\\"-file {name}.bin\".format(name=name), \"add_constraints\": \"set_property INTERNAL_VREF 0.675 [get_iobanks 34]\" } return super().toolchain_prepare(fragment, name, **overrides, **kwargs) def toolchain_program(self, products, name): xc3sprog = os.environ.get(\"XC3SPROG\", \"xc3sprog\") with products.extract(\"{}.bit\".format(name)) as bitstream_filename: subprocess.run([xc3sprog, \"-c\", \"nexys4\", bitstream_filename], check=True) if __name__ == \"__main__\": from .test.blinky import * ArtyA7Platform().build(Blinky(), do_program=True) {\"mode\":\"full\",\"isActive\":false}   Building 1  python3 file.py   This will result in a directory, build, containing the output files:\n top.il: The ilang output for yosys. top.bin: The bitstream to send to the device (e.g. via iceprog) top.rpt: Statistics from nextpnr. The most useful is the cell and LUT top.tim: Timing analysis. Shows how fast you can go. Probably.  ","description":"","tags":null,"title":"[Day07] Synthesis","uri":"/posts/day07/"},{"categories":null,"content":"Assert, Assume, and Cover for fun and profit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14  from nmigen.asserts import Assert, Assume, Cover from nmigen.cli import main_parser, main_runner from somewhere import Adder if __name__ == \"__main__\": parser = main_parser() args = parser.parse_args() m = Module() m.submodules.adder = adder = Adder() m.d.comb += Assert(adder.out == (adder.x + adder.y)[:8]) with m.If(adder.x == (adder.y \u003c\u003c 1)): m.d.comb += Cover((adder.out \u003e 0x00) \u0026 (adder.out \u003c 0x40)) main_runner(parser, args, m, ports=[] + adder.ports())   Past, Rose, Fell, Stable from nmigen.asserts import Assert, Assume, Cover from nmigen.asserts import Past, Rose, Fell, Stable Not ready yet. ","description":"","tags":null,"title":"[Day06] Formal_verification","uri":"/posts/day06/"},{"categories":null,"content":"Simulating The best way to simulate a module is through nMigen’s Simulator.\nDefine you ports Define a ports function in your module which returns an array of your module’s ports:\n1 2 3 4  class YourModule(Elaboratable): ... def ports(self): return [self.youmodule.p1, self.yourmodule.p2, ...]   Create a top-level module Create a top-level module for your simulation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from nmigen import * from nmigen.back.pysim import Simulator, Delay, Settle from somewhere import YourModule if __name__ == \"__main__\": m = Module() m.submodules.yourmodule = yourmodule = YourModule() sim = Simulator(m) def process(): # To be defined sim.add_process(process) # or sim.add_sync_process(process), see below with sim.write_vcd(\"test.vcd\", \"test.gtkw\", traces=yourmodule.ports()): sim.run()    There is currently a bug in nMigen where inputs to your module are not output to the trace file. To get around this, for each such input, place this in your main before the Simulator construction:\n1 2 3 4  input1 = Signal() m.d.comb += yourmodule.input1.eq(input1) ... sim = Simulator(m)   Inside your process, refer to this input as input1, not yourmodule.input1. This will force nMigen to include input1 in the trace file.\n Define your clocks, if any If you have clocks, add each clock after the Simulator constrction, giving the clock period in seconds. For example, a 100MHz clock for clock domain fast_clock and a nearly 166MHz clock for faster clock.\n1 2 3 4  ... sim = Simulator() sim.add_clock(1e-8,domain=\"fast_clock\") sim.add_clock(6e-9,domain=\"faster_clock\")   Leaving out domain will cause the clock period to be assigned to the default clock domain, sync.\nThe process function The process function is a Python generator that nMigen calls to see what to do next in the simulation. Since it is a generator, process must yield a statement to perform. For example:\n1 2 3  def process(): yield x.eq(0) yield y.eq(0xFF)   The above would set x to 0 and y to 0xFF, with effectively no delay between them. You can yield nMigen Value, which you can then use to do various comparisons.\n1 2 3 4 5 6 7 8 9  def process(): yield x.eq(0) yield Delay(1e-8) # delay 10 nano seconds yie y.eq(0xFF) yield Settle() # force all combinational computation to happen. got = yield yourmodule.sum want = yield (x+y)[:8] if got != want: print(f\"Error, result={got:02x},golden={want:02x})   In the above example, x will be set to 0, then there will be 10 ns delay, then y will be set to 0xFF, all combinational logic will be given a chance to settle, and finally yourmodule.sum and (x+y)[:8] will be evaluated, and if they are not equal, a diagnostic message is sent to the terminal output.\nYou can even have more that one process running parallel.\n1 2 3 4 5 6 7 8 9 10  def x_process(): yield Delay(1e-6) yield x.eq(0) yield Settle() def y_process(): yield Delay(1.2e-6) yield y.eq(0xFF) yield Settle() sim.add_process(x_process) sim.add_process(y_process)   In the above example, x will be set to 0 at time 1 us, and y will be set to 0xFF at time 1.2 us.\nWarning: driving the same signal from more than one process can lead to undefined behavior if both processes assign to the signal simultaneously.\nNon-synchronous processes If you want to specify exactly when signals change based on time, then you can create a non-synchronous process. You must add such a process to the simulator via add_process:\n1  sim.add_process(process)   Synchronous process If you want to specify when signals change base on clock edges, then you can create a synchronous process. You can add such a process to the simulator via add_sync_process, specifying the clock domain it should be clocked from:\n1 2  sim.add_sync_process(process1, domain= \"name1\") sim.add_sync_process(process2, domain= \"name2\")   If you yield with no value from a synchronous process, then the process will wait for the next clock edge. Note that for synchronous processes, one clock edge will occur before the process starts, so take that into account when you look at your traces. It is also important to understand when statements are executed in relation to clock edges. They are always executed infinitesimally after the previous clock edge. Thus, in this example.\n1 2 3 4 5  def process(): yield x.eq(0) #step1 yield #step2 yield x.eq(1) #step3 yield #step4   There will be one clock edge that always takes place before the process runs. Then x is set to 0 (step 1). Then another clock edge happens(step 2). x is set to 1 infinitesimally after that clock edge (step 3). Then another clock signals that appear to change coincident with a clock edge actuvally change just after that clock edge. Outputs that change like that can be consider to have been “driven” by the clock edge.\nPassive and active processes Processed may be passive or active. When an active process runs out of things to tell the simulator to do, it asks the simulator to finish. In effect, it controls the endpoint of the simulator. The simulation ends when all active processes are done. A passive process, on the other hand, doesn’t ask the simulator to finish.\nBy default, processes added with add_process and add_sync_process are active. A process can change its mode using yield Active() or yield Passive().\nEnding the simulation As mentioned above, the simulation ends when all active processes are done. This is how sim.run() works.\nHowever, you can instead use sim.run_until(), which lets you end the simulation at a particular time. The run_passive key is False by default, meaning that the simulation will also end if all active processes are done. This behavior can be changed by setting run_passive to True, in which case the simulation will only end once the specified time is reached. For example, the following will run the simulation for 100 microseconds and then stop, regardless of whether the active processes are done.\n1 2  with sim.write_vcd(\"test.vcd\", \"test.gtkw\", traces=yourmodule.ports()): sim.run_until(100e-6, run_passive=True)   Running the simulation and viewing the output The simulation is run simply by running the main module:\n1  python3 main_module.py   The output should be a test.vcd file and a test.gtkw file. Running gtkwave will allow you to view the output. Running it on test.vcd will make you select the signals you want to see when gtkwave opens, while running it on test.gtkw will open gtkwave showing the signals in the traces key that you you gave in the call to sim.write_vcd().\n1 2  gtkwave test.vcd gtkwave test.gtkw   ","description":"","tags":null,"title":"[Day05] Simulations","uri":"/posts/day05/"},{"categories":null,"content":"Spliting and combining signals Slicing signals We can get the least significant bit by x[0] or the most significant bit by x[15].\n1 2 3 4 5 6 7 8 9 10  \u003e\u003e\u003e from nmigen import * \u003e\u003e\u003e x = Signal(16) \u003e\u003e\u003e x (sig x) \u003e\u003e\u003e x.shape() Shape(width=16, signed=False) \u003e\u003e\u003e x[15] (slice (sig x) 15:16) \u003e\u003e\u003e x[15].shape() Shape(width=1, signed=False)   While x[7:0] is the way to extract the eight least significant bits in verilog.But in nMigen we use x[0:8] or x[:8]. It will be Signal_name[start_bit:bits].\n1 2 3 4 5 6 7 8 9 10 11 12  \u003e\u003e\u003e x[7:0] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e File \"/home/waxapple/.local/lib/python3.8/site-packages/nmigen/hdl/ast.py\", line 238, in __getitem__ return Slice(self, start, stop) File \"/home/waxapple/.local/lib/python3.8/site-packages/nmigen/hdl/ast.py\", line 659, in __init__ raise IndexError(\"Slice start {} must be less than slice stop {}\".format(start, stop)) IndexError: Slice start 7 must be less than slice stop 0 \u003e\u003e\u003e x[0:8] (slice (sig x) 0:8) \u003e\u003e\u003e x[0:8].shape() Shape(width=8, signed=False)   Remember that since this is Python, negative indices are offsets from the end, so a way of getting the most significant bit is x[-1].\n1 2  \u003e\u003e\u003e x[-1] (slice (sig x) 15:16)   You can use strides: x[0:8:2] which is signal_name[start_bit:bits:strides].\n\u003e\u003e\u003e x[0:8:2] (cat (slice (sig x) 0:1) (slice (sig x) 2:3) (slice (sig x) 4:5) (slice (sig x) 6:7)) Note that taking bits range selection will always result in unsigned signal.\nYou can even assign to a piece of a signal:\n1 2  m.d.comb += x[:8].eq(y) # same as the x[7:0] = {y[7:0]}; in verilog   Tip: Using a slice when comparing In a situation like this:\n1 2 3 4 5  a = Signal(unsigned(16)) b = Signal(unsigned(16)) c = Signal(unsigned(16)) m.d.comb += c.eq(a+b)   We expect that if a+b overflows, c will just be the lower 16 bits of the result.\n1 2 3 4 5  a = Signal(unsigned(16)) b = Signal(unsigned(16)) z = Signal() m.d.comb += z.eq((a+b)== 0)   However, z will be a 17-bit signal. So a 16-bit overflow is not a 17-bit overflow, and this will result in comparison failure. Such as a = 0xffff and b = 0x0001, the addition will be z = 0x10000, which obviously not zero as we expected.\nTherefore, be careful to slice the result\n1  m.d.comb += z.eq((a+b)[:16] == 0)   Alternatively, just use an intermediate signal (not recommanded):\n1 2 3 4  tmp = Signal(unsigned(16)) m.d.comb += tmp.eq(a+b) m.d.comb += z.eq(tmp == 0)   This becomes especially insidious when combining unsigned and signed signals:\n1 2 3 4 5  ptr = Signal(unsigned(16)) addr = Signal(unsigned(16)) offset = Signal(signed(5)) m.d.comb += ptr.eq(addr + offset)   we expect ptr to be a 16-bit value, since that is what we set it to be. However, what happens here? Suppose addr is 0 and offset is -1. Will this comparison work? No, sorry my dear. It wouldn’t work. Consider that adder range from 0x7FFF to 0xFFFF and offset range from 0x7 to 0xF, which is max((+32767 ~ -32768) + (+7 ~ -8) )= 0x8006\n1 2  y = Signal() m.d.comb += y.eq((addr + offset) == 0xFFFF )   So the result of addr+offset in this is -1, which 2’s complement 18-bit is 0x3FFFF. If we slice it, it will be 0xFFFF.\nConcatenating signals You can create a new signal out of other signals using Cat:\n1  m.d.comb += x.eq(Cat(a, b, ...))   This concatenates the given signals first element last This is important that a in the example above ends up as the least significant bits of x. That is, the concatenation of a and b is not ab but ba.\nIt is now easy to swap the bytes of a 16-bit signal:\n1  m.d.sync += x.eq(Cat(x[8:], x[:8]))   You can also assign to a Cat, so swapping the bytes can be accomplished in this way also:\n1  m.d.sync += Cat(x[8:], x[:8]).eq(x)   Replicating signals You can replicate a signal by concatenating it to itself via Cat(x,x). But you can also replicate the signal via Repl(x,2) Repl with Cat can be used together to, for example, signed-extend a value:\n1 2 3 4  uint16 = Signal(unsigned(16)) int32 = Signal(signed(32)) m.d.comb += int32.eq(Cat(uint16, Repl(uint16[15],16)))   Of course, the same can be done by simply using the right signal types:\n1 2 3 4  uint16 = Signal(unsigned(16)) int32 = Signal(signed(32)) m.d.comb += int32.eq(uint16)   The generated cide will do the right thing.\nArrays You can create an array of signals like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # All of these create an array of 3 16-bit elements: # Creates an array from a, b, c: a = Signal(unsigned(16)) b = Signal(unsigned(16)) c = Signal(unsigned(16)) abc = Array([a, b, c]) # Creates an array of 16-bit signals: x = Array([Signal(unsigned(16)), Signal(unsigned(16)), Signal(unsigned(16)) ]) # Also creates an array of 16-bit signals, taking  y = Array([Signal(unsigned(16)) for_ in range(3)])   You can even create multidimensional arrays:\n1 2  # Creates a 3 by 5 array of 16-bit signals: yy = Array([Array[Signal(unsigned(16)) for _ in range(5)] for _ in range(3) ])   You can index into the array with a constant:\n1  z = y[2]   This will result in an “elaborate time” error if the index is out of bounds. However, you can also index with another signal:\n1 2  i = Signal(unsigned(16)) z = y[i]   Of course, during elaboration this will not result in any error. The actual result depends on runtime. It is best to ensure as much as possible that your access is not invalid. One way is to declare the index to only have a valid range.\n1 2 3 4  y = Array([Signal(unsigned(16)) for _ in range(5)]) i = Signal.range(5) z = y[i]   Of course, there is nothing to prevent i from being 5, 6, or 7, since it is a 3-bit signal. Another way is to simply deal with invalid values:\n1 2 3  y = Array([Signal(unsigned(16)) for _ in range(5)]) i = Signal.range(5) z = y[i % 4]   Note here, it will still result in unexpected result. In the end, you will have to formally verify that i will only contain valid values.\nRecords A Record is a bundle of signals. To define a Record, we first must define a Layout.\nLayouts 1 2 3 4 5 6 7 8  from nmigen.hdl.rec import * class MyLayout(Layout): def __init__(self): super().__init__([ (\u003csignal_name\u003e, \u003cshape|layout\u003e [, \u003cdirection\u003e]), (\u003csignal_name\u003e, \u003cshape|layout\u003e [, \u003cdirection\u003e]), ])   Here is an example of a bus with 8-bit data, 16-bit address line, and some control signals:\n1 2 3 4 5 6 7 8  class BusLayout(Layout): def __init__(self): super().__init__([ (\"data\", unsigned(8)), (\"addr\", unsigned(16)), (\"wr\",1), (\"en\",1), ])   If your bus is very complex and easy to reuse another bus, you can define a bus by another bus.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class DataBusLayout(Layout): def __init__(self): super().__init__([ (\"data\",unsigned(8)) ]) class AddrBusLayout(Layout): def __init__(self): super().__init__([ (\"addr\",unsigned(16)) ]) class AllBusLayout(Layout): def __init__(self): super().__init__([ (\"addr_bus\",AddrBusLayout()), (\"data_bus\",DataBusLayout()), ])   Laying out a record with a layout Once a Layout is defined, you can define a Record using that Layout, and use it as a signal:\n1 2 3 4 5 6 7 8 9 10 11 12  class Bus(Record): def __init__(self): super().__init__(BusLayout()) ... # Later in a module: self.bus = Bus() m.d.comb += self.bus.data.eq(0xFF) m.d.sync += self.bus.wr.eq(0) # Can assign a bus by a bus self.bus2 = Bus() m.d.comb += self.bus2.eq(self.bus)   Directions and connecting records It is often advantageous to define signals so that the zero value means either invalid or inactive. That way, you can have many of those signals and logical-or them together. For example, you might have three modules, each of which output a one-bit write signal, but only one module will write at a time. Then if your write signal is active high( zeros means no write), you can simply logical-or the write signal from each module together to get a master write signal. 1 2  self.master_record = Bus() m.d.comb += self.master_record.connect(bus1, bus2, bus3, ...)   The connect method on a record returns an array of statement which logical-ors each signal together. The exactly same thing could be accomplished “manually”.\n1 2  self.master_record = Bus() m.d.comb += self.master_record.eq(bus1 | bus2 | bus3 |...)   The disadvantage is that connect can connect parts of records, if the field names matched. In this sense, the “subordinate” records must have every signal that the “master” record has. That is, the “subordinate” records can have extra signals, but the “master” record must not.\nFan-out is where each subordinate record gets a copy of the master record. If the direction of each signal in the layout of record is DIR_FANOUT, then you can connect several records to a “master” record like this:\n1 2  self.master_record = Bus() m.d.comb += self.master_record.connect(bus1, bus2, bus3, ...)   The syntax is exactly the same, but the direction is different, from master record to each subordinate record. Again, you could do this “manually”:\n1 2 3 4 5 6 7  self.master_record = Bus() m.d.comb += [ bus1.eq(self.master_record), bus2.eq(self.master_record), bus3.eq(self.master_record), ... ]   But this is longer, and also doesn’t handle when the master record has extra signals that not in the subordinate records.\n","description":"","tags":null,"title":"[Day04] Bit selection","uri":"/posts/day04/"},{"categories":null,"content":"If-Elif-Else you cannot use the standard python if-elif-else statements to create statements. Instead, using nMigen branching.\n1 2 3 4 5 6  with m.If(condition1): m.d.comb += statements1 with m.Elif(condition2): m.d.comb += statements2 with m.Else(): m.d.comb += statements3   If you use regular Python if-elif-else, then those will be evaluated during generation of the logic, not the logic itself. This can be useful if you want a flag to cause different logic implement to be generated, and this is a good use of platform string pass to elaborate().\n1 2 3 4  if (platform== \"KC705\") m.d.comb += statement1 else: m.d.comb += statement2   If platform is \"KC705\" then statement1 will be implement in generated hardware, otherwise only statement2 will be implement in the design.\nConditions The conditions in If-Elif-Else are cimparisons, for example a == 1 or (a \u003e= b) \u0026 (a \u003c= c). Note that each comparison will be one-bit comparison.\nIf you have a signal with more than one bit and use it as the condition, use with m.If(a):, then the condition will be true if any bit in a is 1.\nSwitch-Case-Default You can use Switch-Case-Default just as in standard HDLs using the following with constructs:\n1 2 3 4 5 6 7  with m.Switch(expression): with m.Case(value1): statements1 with m.Case(value2): statements2 with m.Default(): statements3   Although it is suggested that using full-case switch that we used to do in verilog. You can use multiple values in one case statement.\n1 2 3 4 5  with m.Switch(expression): with m.Case(value1,value2): statements1 with m.Default(): statements3   You can leave out the Defalt(), but not suggest you to do that.\n1 2 3 4  m.d.comb += x.eq(1) with m.Switch (y): with m.Case(0,1,2): m.d.comb += x.eq(2)   In this example, if y is in [0, 1, 2] then x is assigned 2. Otherwise x retains its value of 1.\n Recall the section on overriding statements. One signal can only assigned in only one clock domain.  Specify a bit patterns The way to specify a matching pattern in a Case is with a Python string of binary digits. For example, \"0011101011\". A don’t-care bit is specified using a dash -, so for example \"00111-----\". The number of bits in the string must exactly the same as the number of bits in the expression it is being compared to.\n1 2  with m.If(a.matches(\"11---\",3,b)): statement1   Is equivelent to\n1 2 3  with m.Switch(a): with m.Case(\"11---\",3,b): statement1   ","description":"","tags":null,"title":"[Day03] Branching","uri":"/posts/day03/"},{"categories":null,"content":"Domains A domain in its basic definition, is a grouping of logic cells. If consider a module as a blackbox. With its inputs and outputs, any given output is generated within one and only one domain.\nModules come with two domain built in: a combinational domain and a sequential(synchronous) domain.\nCombinational Logic that contains no clocked elements is called combinational logic. This is one of the domain that a Module contains. It is always named comb, and it can be accessed via m.d.comb.\nm means Module and d means domain.\nSynchronous Logic that contains clocked elements is called synchronous (a.k.a sequential circuit) because all the FFs are triggered by particular clock domain. Each clock domain also has a reset signal which can reset all FFs to a given state. Finally, the domain specifies the edge of its clock on which all the FFs change: posedge or negedge.\nUnless otherwise specified, there is one synchronous domain in a Module called sync. It can be accessed via m.d.sync.\nCreating more domains There is no reason to create combinational domains. As mentioned above, modules already contain one combinational domain, comb.\nYou can create a synchronous clock domain using ClockDomain(\"\u003cdomain-name\u003e\", clk_edge=\"pos|neg\"). This gives you both the clock and the reset signal for the domain. By default, the domain name is sync and the clock edge is pos.\n1 2 3 4 5  m = Module() mydomain = ClockDomain(\"clk\") m.domains += mydomain m.d.mydomain += ... # logic to add in the \"mydomain\" clock domain.   You can access a domain within a module by its name. So a domain created via ClockDomain(“my clock”) is accessed via m.d.myclock or m.d[\"myclk\"]. \\\n ClockSignal(domain=\"\u003cdomain\u003e\") gives you the clock signal for the given domain. ResetSignal(domain=\"\u003cdomain\u003e\") gives you the reset signal for the given domain.  Tips: Clock domains with the same clock but different edges. This can be done simply by creating one clockdomain\n1 2  pos = ClockDomain(\"pos\") neg = ClockDomain(\"neg\", clk_edge=\"neg\")   Next, assign them with same clock driven\n1 2  neg.clk = pos.clk neg.rst = pos.rst   And then you can add these to the module. We can add more than domain to a module with the same statement.\n1  m.domains += [pos, neg]   Access to domains A module can access its domains via its d attribute. By default, if a synchronous domain is added to a module’s domain, then all modules everywhere will also have access to that domain via their d attribute, even if that module is not a submodule of the module where the domain was added.\n1 2 3 4 5 6  m = Module() m2 = Module() m.domains += ClockDomain(\"thing\") m.d.thing += # logic # This is implicity  m2.d.thing += #logic   If you want to explicitly inhibit this global propagation by setting the local named parameter of the ClockDomain to True.\n1 2 3 4 5 6  m = Module() m2 = Module() m.domains += ClockDomain(\"thing\", local=True) m.d.thing += # logic # Error will occur here. m2.d.thing += # logic   Ports The equivalent of ports in a module is public attributes. In the following example, a and data are publicly available to other modules, while b is not, just as a and data are publicly available to other python classes, and b is not.\n1 2 3 4 5 6 7 8 9 10  class ThingBlock(Elaboratable): def __init__(self): # Public accessible self.a = Signal() self.data = Signal(8) def elaborate(self, platform: str): m = Module() # Internal use reg/wire. b = Signal() return m   Reset/default values for signals If a Signal is set in the combinational or synchronous domain, then you can specify the default value of the signal if it is not set. By default value of the signal if it is not set. By default, it is zero, but for a non-zero value, you can specify the default value for a signal when constructing the signal by setting the reset named parameter in the constructor. For example, this create a 16-bit signed signal, self.x, which initial value set to 0xFFFF.\n1  self.x = Signal(signed(16), reset=0xFFFF) # initial value \"0xFFFF\"   Explicitly not resetting For synchronous signals(that is, a signal set in a synchronous domain), you can specify that it is not reset on the reset signal, instead only getting an initial balue on power-up. This is done by setting the reset_less named parameter in the constructor to True\n1  self.x = Signal(signed(16),reset= 0xFFFF, reset_less = True)   This is especially useful during simulation or formal verification where you want to activate the reset, but keep some signals “outside” the reset. For example, a cycle counter that maintains its count across resets.\nBasic operations Statements nMigen doesn’t convert Python to hardware. In essence, what you are writing using nMigen is a generator of logic, not the logic itself. So if you want to assign one Value to take the value of another, you don’t write a = b, but instead you call the method of a that generates the equality: a.eq(b). This is known as a statement.\nHowever, many math operators are overridable in Python, since these translate to calls to Python functions. So for example, you can write a.eq(b+1) instead of something like a.eq(b.plus(1)) because Python addition can be overrideen to a function callm and nMigen’s Signal class does that for all such operators (= is still not overrided).\nList of directly translatable Python operators    Operator Operation Notes     ~ inversion    - arithmetic negation    + addition    * multiplication    % modulus    // division integer division, rounding down   \u003c\u003c shift left    \u003e\u003e shift right Effectively arithmetic, see below.   \u0026 bitwise and    ` ` bitwise or   ^ bitwise xor    == equality    != inequality    \u003e greater than    \u003e= greater than or equal to    \u003c less than    \u003c= less than equal to      Note that there are no translatable Python logical operators (and,or). The logical reduction functions any and all are not avaliable in nMigen expressions.\nAttemped to convert nMigen value to boolean error will occur.\n  Shift right is effectively arithmetic, where the sign bit is present for signed values or zero for unsigned Values.\n Effects of operations on result width Two unsigned/signed 4-bit signals addition will result in unsigned/signed 5-bit result.\n1 2 3 4 5  \u003e\u003e\u003e s1 = Signal(signed(4)) \u003e\u003e\u003e s2 = Signal(signed(4)) \u003e\u003e\u003e v2 = s1 + s2 \u003e\u003e\u003e v2.shape() Shape(width=5, signed=True)   Multiplexing signals Mux() returns one signal if the condition is true, the other signal otherwise:\n1  y.eq(Mux(cond,x1,x2))   In this case, if cond is true then y is set to x1, otherwise x2. It is the same as y = cond?x1:x2;.\nMux cannot be used on the left-hand side of any assignment.\nPlacing statements in domains Statements are written in the combinational domain of a module as we used to in verilog. Ofcourse, can be used in sequential circuits.\n1 2 3 4  # Combinational circuit m.d.comb += x.eq(y+1) # Sequential circuit m.d.sync += x.eq(y+1)   For example, y is IDLE and x is next_state.\nAdding multiple statements The += operator for a domain can take one statement, or a list of statements, which is pretty ease to use.\n1 2 3 4  m.d.comb += [ x.eq(y+1), z.eq(w+2) ]   Conflict statements will be override If a statement sets the same signal that previous statement set, the the second set takes precedence.\n1 2  m.d.comb += x.eq(y+1) m.d.comb += x.eq(y+2)   In this case, x will get y+2 not y+1. Remember that one signal can only be assigned to one domains, otherwise, it will result in a driver-driver conflict.\n1 2 3  # Wrong code m.d.comb += x.eq(y+1) m.d.sync += x.eq(y+1)   ","description":"","tags":null,"title":"[Day02] Basic terminology","uri":"/posts/day02/"},{"categories":null,"content":"Basic structure of modules The tutorial is followed by https://github.com/RobertBaruch/nmigen-tutorial/ Thumbs up for his contributions.\n1 2 3 4 5 6 7 8 9  from nmigen import * from nmigen.build import Platform class ThingBlock(Elaboratable): def __init__(self): pass def elaborate(self, platform: Platform) -\u003e Module: m = Module() return m   Elaborating a module 1 2 3 4 5 6 7 8 9 10 11  from nmigen.cli import main if __name__== \"__main__\": sync = ClockDomain() block = ThingBlock() m = Module() m.domains += sync m.submodules += block main(m, ports=[sync.clk,sync.rst])    main(module, ports=[], platform=\"\") translate the given module into verilog. This is call elaboration. All elaborate() medthod will have its platform argument set to the given platform like particular chips or evaluation boards.  python3 thing.py generate -t [v|il] \u003e thing.[v|il]  If you encounter any error message, Back to day00 and install the pre-requisties.\n  Choose RTLIL if using yosys.  ","description":"","tags":null,"title":"[Day01] Basic nMigen","uri":"/posts/day01/"},{"categories":null,"content":"第一天接觸nMigen, 先來安裝　nMigen! 安裝Prerequisites sudo apt-get install build-essential clang bison flex libreadline-dev \\ gawk tcl-dev libffi-dev git mercurial graphviz \\ xdot pkg-config python python3 libftdi-dev gperf \\ libboost-program-options-dev autoconf libgmp-dev \\ cmake 安裝有的沒的必備程式 參考 https://symbiyosys.readthedocs.io/en/latest/install.html\n安裝nMigen pip install git+https://github.com/m-labs/nmigen.git pip install git+https://github.com/m-labs/nmigen-boards.git 安裝之後就可以開始學習如何使用nMigen製作電路\n Boolector (important!)  # Download and build Boolector git clone https://github.com/boolector/boolector cd boolector # Download and build Lingeling ./contrib/setup-lingeling.sh # Download and build BTOR2Tools ./contrib/setup-btor2tools.sh # Build Boolector ./configure.sh \u0026\u0026 cd build \u0026\u0026 make ./configure.sh --py3 cd build make sudo cp build/bin/{boolector,btor*} /usr/local/bin/ sudo cp deps/btor2tools/bin/btorsim /usr/local/bin/ Value in migen Const 永不變 1 2 3 4 5 6 7 8 9 10  from nmigen import * a = Const(10) a.shape() \u003e\u003e Shape(width=4, signed=False) a = Const(10) a.shape() \u003e\u003e Shape(width=5, signed=True) x = Const(3,range(-5,11)) x.shape() \u003e\u003e Shape(width=5, signed=True)   可以使用Enum 來做常數狀態 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  from enum import Enum, unique @unique class Func(Enum): NONE = 0 ADD = 1 SUB = 2 MUL = 3 DIV = 4 ... \u003e\u003e\u003e x = Const(2, Func) \u003e\u003e\u003e x.shape() unsigned(3) \u003e\u003e\u003e x = Value.cast(Func.NONE) \u003e\u003e\u003e x const 3'd0   Signal 是 Wire或者reg 1 2 3 4  \u003e\u003e\u003e from nmigen import * \u003e\u003e\u003e A = Signal(signed(8)) \u003e\u003e\u003e A.shape() Shape(width=8, signed=True)   1 2 3  \u003e\u003e\u003e x = Signal(range(-5,11)) \u003e\u003e\u003e x.shape() Shape(width=5, signed=True)   1 2 3 4 5 6  \u003e\u003e\u003e x = Signal(Func) \u003e\u003e\u003e x (sig x) \u003e\u003e\u003e x = Signal(unsigned(16),name=\"dout\") \u003e\u003e\u003e x.name 'dout'     但是我安裝Miniconda 後整個WSL的ssl都掛了，建議不要安裝\n安裝Miniconda 因為我是用WSL，也沒有GUI，就直接用miniconda就好了。\nwget https://repo.anaconda.com/miniconda/Miniconda3-py39_4.9.2-Linux-x86_64.sh chmod +x Miniconda3-py39_4.9.2-Linux-x86_64.sh ./Miniconda3-py39_4.9.2-Linux-x86_64.sh  ","description":"","tags":null,"title":"[Day00] nMigen 戰鬥","uri":"/posts/day00/"}]